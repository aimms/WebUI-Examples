## ams_version=1.0

LibraryModule AimmsProLibrary {
    Prefix: pro;
    Interface: {
        PRO_API +
        session::Public_Declarations +
        Public_Framework_Declarations +
        Worker_Setup +
        Case_Load_and_Save +
        DLL_Interface +
        WebUI_Support
    }
    Section AIMMS_Version_Independent_Functionality {
        Section PRO_API {
            DeclarationSection Constants {
                Parameter PROMFLAG_ACK {
                    Range: integer;
                    Property: NoSave;
                    Definition: 1;
                }
                Parameter PROMFLAG_PRIORITY {
                    Range: integer;
                    Property: NoSave;
                    Definition: 2;
                }
                Parameter PROMFLAG_SYNC_ONLY {
                    Range: integer;
                    Property: NoSave;
                    Definition: 4;
                }
                Parameter PROMFLAG_LIVE {
                    Range: integer;
                    Property: NoSave;
                    Definition: 8;
                }
                Parameter PROMFLAG_REQUEST {
                    Range: integer;
                    Property: NoSave;
                    Definition: 16;
                }
                Parameter PROMFLAG_RESPONSE {
                    Range: integer;
                    Property: NoSave;
                    Definition: 32;
                }
                Parameter PROMFLAG_ERROR {
                    Range: integer;
                    Property: NoSave;
                    Definition: 64;
                }
                Parameter PROMFLAG_SESSION {
                    Range: integer;
                    Property: NoSave;
                    Definition: 128;
                }
                Parameter PROMFLAG_USER {
                    Range: integer;
                    Property: NoSave;
                    Definition: 256;
                }
                Parameter PROTS_CREATED {
                    Range: integer;
                    Property: NoSave;
                    Definition: 0;
                    Comment: "Worker created but project not opened yet";
                }
                Parameter PROTS_QUEUED {
                    Range: integer;
                    Property: NoSave;
                    Definition: 1;
                    Comment: "Project opening requested and being executed";
                }
                Parameter PROTS_INITIALIZING {
                    Range: integer;
                    Property: NoSave;
                    Definition: 2;
                    Comment: "Project opening requested and being executed";
                }
                Parameter PROTS_READY {
                    Range: integer;
                    Property: NoSave;
                    Definition: 3;
                    Comment: "Waiting for new tasks to be executed";
                }
                Parameter PROTS_RUNNING {
                    Range: integer;
                    Property: NoSave;
                    Definition: 4;
                    Comment: "Running a task";
                }
                Parameter PROTS_CLOSING {
                    Range: integer;
                    Property: NoSave;
                    Definition: 5;
                    Comment: {
                        "Project closing; no more tasks will be handled"
                    }
                }
                Parameter PROTS_FINISHED {
                    Range: integer;
                    Property: NoSave;
                    Definition: 6;
                    Comment: {
                        "Project closed; no more tasks will be handled"
                    }
                }
                Parameter PROTS_TERMINATED {
                    Range: integer;
                    Property: NoSave;
                    Definition: 7;
                    Comment: {
                        "Project terminated during execution; no more tasks will be handled"
                    }
                }
                Parameter PROTS_ERROR {
                    Range: integer;
                    Property: NoSave;
                    Definition: 8;
                    Comment: {
                        "Project ended with an error; no more tasks will be handled"
                    }
                }
                Parameter PROTS_DELETED {
                    Range: integer;
                    Property: NoSave;
                    Definition: 9;
                    Comment: {
                        "Project ended with an error; no more tasks will be handled"
                    }
                }
                Parameter AIMMSAPI_INTERRUPT_EXECUTE {
                    Range: integer;
                    Property: NoSave;
                    Definition: 1;
                    Comment: "Interrupt the current running procedure";
                }
                Parameter AIMMSAPI_INTERRUPT_SOLVE {
                    Range: integer;
                    Property: NoSave;
                    Definition: 2;
                    Comment: "Interrupt the current solve statement";
                }
                Parameter PROA_ADMIN_GROUP {
                    Property: NoSave;
                    Definition: 128;
                }
            }
            Section User_Management {
                Function GetPROEnvironment {
                    Range: string;
                    Body: {
                        GetPROEnvironment := PROEnvironment;
                    }
                }
                Function GetPROUserName {
                    Range: string;
                    Body: {
                        GetPROUserName := PROUserName;
                    }
                }
                Function GetPROTempFolder {
                    Range: string;
                    Body: {
                        GetPROTempFolder := PROTempFolder;
                    }
                }
                Function GetPROEndPoint {
                    Range: string;
                    Body: {
                        GetPROEndPoint := PROEndPoint;
                    }
                }
                Function GetPROSUserBucket {
                    Range: string;
                    Body: {
                        GetPROSUserBucket := PROS_ROOT_USER_BUCKET + "/" + PROEnvironment + "/" + PROUserName;;
                    }
                }
                Procedure GetCurrentUserInfo {
                    Arguments: (environment,username,userBucket,userGroups,userGroupname);
                    Body: {
                        ! Initialize PRO Framework (if not initialized yet)
                        ret := Initialize();
                        if not (ret) then return 0; endif;
                        
                        for userGroup do
                            SetElementAdd(userGroups,UserGroupElement,userGroup);
                            userGroupname(UserGroupElement) := PROUserGroupName(userGroup);
                        endfor;
                        
                        environment := GetPROEnvironment;
                        username := GetPROUserName;
                        userBucket := GetPROSUserBucket;
                        
                        return 1;
                    }
                    StringParameter environment {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter username {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter userBucket {
                        Property: Output;
                        InitialData: "";
                    }
                    Set userGroups {
                        Index: usrGrp;
                        Parameter: UserGroupElement;
                        Property: Output;
                    }
                    StringParameter userGroupname {
                        IndexDomain: usrGrp;
                        Property: Output;
                    }
                    Parameter ret;
                }
            }
            Section Procedure_Preparation_for_Remote_Execution {
                Parameter DebugServerSession {
                    Default: 0;
                    Property: NoSave;
                }
                Parameter DeveloperModeDelegation {
                    Default: 0;
                    Property: NoSave;
                    Comment: "0 = ask, 1 = delegate always, 2 = always solve locally";
                }
                StringParameter DefaultRequestDescription {
                    InitialData: "";
                }
                Procedure DelegateToServer {
                    Arguments: {
                        (procedureName,requestDescription,requestQueue,timeOut,flags,waitForCompletion,completionCallback,
                         inputCase,delegationOverride,authorization,licenseName,priorityAdjustment,scheduledAt)
                    }
                    Body: {
                        ! Determine the procedure name if not given explicitly
                        if (procedureName = '') then
                            DetermineProcedureName(procedureName);
                        endif;
                        
                        ! Check conditions to start a new session or send to an existing session.
                        if (requestQueue = "") then
                            description := if ( requestDescription = "" ) then DefaultRequestDescription else requestDescription endif;
                            return DelegateToNewSession(procedureName,description,timeOut,waitForCompletion,completionCallback,inputCase,delegationOverride,authorization,licenseName,priorityAdjustment,scheduledAt);
                        else
                            return DelegateToPeer(requestQueue,procedureName,flags);
                        endif;
                    }
                    ElementParameter err {
                        Range: errh::PendingErrors;
                    }
                    StringParameter clientQueue;
                    StringParameter requestQueue {
                        Property: Optional;
                    }
                    StringParameter requestDescription {
                        Property: Optional;
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Default: '';
                        Property: Optional;
                    }
                    Parameter timeOut {
                        Range: integer;
                        Default: 3600000;
                        Property: Optional;
                    }
                    Parameter flags {
                        Range: integer;
                        Default: 0;
                        Property: Optional;
                    }
                    Parameter ret;
                    Parameter waitForCompletion {
                        Range: binary;
                        Property: Optional;
                    }
                    ElementParameter completionCallback {
                        Range: AllProcedures;
                        Property: Optional;
                    }
                    Parameter waited;
                    Parameter delegationOverride {
                        Property: Optional;
                        Comment: {
                            " -1 : always run locally,
                               0 : ask if running in developer mode,
                            >= 1 : delegate if override level > level of current session"
                        }
                    }
                    StringParameter inputCase {
                        Property: Optional;
                    }
                    StringParameter authorization {
                        Property: Optional;
                    }
                    StringParameter licenseName {
                        Property: Optional;
                    }
                    Parameter priorityAdjustment {
                        Range: integer;
                        Property: Optional;
                    }
                    StringParameter scheduledAt {
                        Property: Optional;
                    }
                    StringParameter description;
                }
                Procedure DelegateToNewSession {
                    Arguments: {
                        (procedureName,requestDescription,timeOut,waitForCompletion,completionCallback,inputCase,
                         delegationOverride,authorization,licenseName,priorityAdjustment,scheduledAt)
                    }
                    Body: {
                        ! Determine whether we need to delegate or run locally
                        if (RunLocally(delegationOverride)) then
                            return 0;
                        else
                            ! Run remotely
                        
                            if procedureName = '' then
                                DetermineProcedureName(procedureName);
                            endif ;
                        
                            ! Create a new session to do it
                            session::RunManagedSession(clientQueue,requestQueue,procedureName,delegationOverride,timeOut,requestDescription,callbackProcedure:completionCallback,
                                                       InputCase:inputCase,Authorization:authorization,licenseName:licenseName,priorityAdjustment:priorityAdjustment,scheduledAt:scheduledAt);
                        
                            if waitForCompletion then
                                waited := 0;
                                while (waited < timeout and not messaging::WaitForMessages(clientQueue,PROMFLAG_SESSION,1000)) do
                                    waited += 1000;
                                endwhile;
                            endif ;
                        
                            return 1;
                        endif;
                    }
                    ElementParameter err {
                        Range: errh::PendingErrors;
                    }
                    StringParameter clientQueue;
                    StringParameter requestQueue;
                    StringParameter requestDescription {
                        Property: Optional;
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Default: '';
                        Property: Optional;
                    }
                    Parameter timeOut {
                        Range: integer;
                        Default: 3600000;
                        Property: Optional;
                    }
                    Parameter ret;
                    Parameter waitForCompletion {
                        Range: binary;
                        Property: Optional;
                    }
                    ElementParameter completionCallback {
                        Range: AllProcedures;
                        Property: Optional;
                    }
                    Parameter waited;
                    Parameter delegationOverride {
                        Property: Optional;
                        Comment: {
                            " -1 : always run locally,
                               0 : ask if running in developer mode,
                            >= 1 : delegate if override level > level of current session"
                        }
                    }
                    StringParameter inputCase {
                        Property: Optional;
                    }
                    StringParameter authorization {
                        Property: Optional;
                    }
                    StringParameter licenseName {
                        Property: Optional;
                    }
                    Parameter priorityAdjustment {
                        Range: integer;
                        Property: Optional;
                    }
                    StringParameter scheduledAt {
                        Property: Optional;
                    }
                }
                Procedure DelegateToCurrentSession {
                    Arguments: (procedureName,flags);
                    Body: {
                        ret := Initialize();
                        HandleError(ret);
                        
                        if procedureName = '' then
                            DetermineProcedureName(procedureName);
                        endif ;
                        
                        ! Call remotely
                        return DelegateToPeer(session::CurrentSessionQueue,procedureName,flags);
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Default: '';
                        Property: Optional;
                    }
                    Parameter flags {
                        Range: integer;
                        Default: 0;
                        Property: Optional;
                    }
                    Parameter ret;
                }
                Procedure DelegateToClient {
                    Arguments: (procedureName,flags);
                    Body: {
                        !If the user did not provide the name of the procedure, then first find this
                        !with using error handling
                        if ProcedureName = '' then
                            DetermineProcedureName(procedureName);
                        endif ;
                        
                        return DelegateToPeer(clientQueueID,procedureName,flags);
                    }
                    ElementParameter err {
                        Range: errh::PendingErrors;
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Default: '';
                        Property: Optional;
                    }
                    Parameter flags {
                        Range: integer;
                        Default: 0;
                        Property: Optional;
                    }
                    Parameter ret;
                }
                Procedure DelegateToPeer {
                    Arguments: (requestQueue,procedureName,flags);
                    Body: {
                        if ((not requestQueue) or IsHandlingQueue(requestQueue)) then
                            return 0;
                        endif;
                        
                        !If the user did not provide the name of the procedure, then first find this
                        !with using error handling
                        if ProcedureName = '' then
                            DetermineProcedureName(procedureName);
                        endif ;
                        
                        ! Call remotely
                        ret := client::SendRunProcedure(requestQueue,procedureName,procedureName,-1,flags);
                        if (ret) then
                            management::LocalLogInfo("Execution request: '" + procedureName + "' at " + requestQueue);
                        else
                            management::LocalLogError("Execution request failed: '" + procedureName + "' at " + requestQueue);
                        endif;
                        
                        return 1;
                    }
                    StringParameter requestQueue {
                        Property: Input;
                    }
                    ElementParameter err {
                        Range: errh::PendingErrors;
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Default: '';
                        Property: Optional;
                    }
                    Parameter flags {
                        Range: integer;
                        Default: 0;
                        Property: Optional;
                    }
                    Parameter ret;
                }
                Function CurrentDelegationLevel {
                    Body: {
                        CurrentDelegationLevel := workerDelegationLevel;
                    }
                }
                Function IsRunningAtServer {
                    Range: binary;
                    Body: {
                        IsRunningAtServer := openedAsWorker;
                    }
                }
                Function GetPROLastErrorMessage {
                    Range: string;
                    Body: {
                        GetPROLastErrorMessage := PROLastErrorMessage;
                    }
                }
            }
            Section Extended_API {
                Procedure GetVersionFullInfo {
                    Arguments: (versionID,path,bucket,object,objFileName,objFileType,objFileSize,objAuthorization,lastVersionID,dateCreated);
                    Body: {
                        ret := storage::GetVersionInfo(versionID, path, bucket, object, objFileSize, dateCreated);
                        if not (ret) then return 0;
                        else
                                ret := storage::GetObjectInfo(path + "/" + bucket, object, objFileName, objFileType, numberOfVersions, objAuthorization, lastVersionID);
                                if not (ret) then return 0; endif;
                        endif;
                        return 1;
                    }
                    StringParameter versionID {
                        Property: Input;
                    }
                    StringParameter path {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter bucket {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter object {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter objFileName {
                        Property: Output;
                        InitialData: "";
                    }
                    StringParameter objFileType {
                        Property: Output;
                        InitialData: "";
                    }
                    Parameter objFileSize {
                        Property: Output;
                        InitialData: 0;
                    }
                    StringParameter objAuthorization {
                        Property: Output;
                        InitialData: "";
                    }
                    Parameter ret;
                    Parameter numberOfVersions {
                        InitialData: 0;
                    }
                    StringParameter dateCreated {
                        Property: Output;
                    }
                    StringParameter lastVersionID {
                        Property: Output;
                    }
                }
                Procedure SaveVersionInFolder {
                    Arguments: (versionID,selectFolder);
                    Body: {
                        if DirectorySelect(selectFolder,selectFolder,"Select Destination Folder") then
                        		tempFolder := PROTempFolder + "\\folder";
                                if not DirectoryExists(tempFolder) then
                                    DirectoryCreate(tempFolder);
                                endif;
                                ret := GetObjectVersion(versionID,tempFolder,getFileName);
                                if not (ret) then return 0; endif;
                        
                                if not FileMove(tempFolder + "\\" + getFileName, selectFolder, 1) then
                                    raise error CurrentErrorMessage code 'PRO-Error-moving-file' ;
                                endif;
                        endif;
                        return 1;
                    }
                    StringParameter versionID {
                        Property: Input;
                    }
                    StringParameter getFileName {
                        InitialData: "";
                    }
                    Parameter ret;
                    StringParameter selectFolder {
                        Default: "";
                        Property: InOut;
                    }
                    StringParameter tempFolder;
                }
                Procedure GetObjectVersion {
                    Arguments: (versionID,folder,getFileName);
                    Body: {
                        ! create output folder if necessary
                        if not DirectoryExists(folder) then
                           	DirectoryCreate(folder);
                        endif;
                        
                        if openedAsWorker then
                                ! Worker sessions do not have buffer
                                return storage::GetObjectVersionUnbuffered(versionID,folder,getFileName);
                        else
                                bufferPath := PROTempFolder + "\\prosbuf";
                                if not DirectoryExists(bufferPath) then
                                    DirectoryCreate(bufferPath);
                                endif;
                                bufferedFilePath := bufferPath + "\\" + versionID;
                                if not FileExists(bufferedFilePath) then
                                        ! Get the file and add to the buffer
                                        ret := storage::GetObjectVersionUnbuffered(versionID,folder,getFileName);
                                        if not (ret) then return 0; endif;
                        
                                        ret := FileCopy(folder + "\\" + getFileName,bufferedFilePath);
                                        if not (ret) then return 0; endif;
                        
                                        ! Check buffer total size (files can be deleted here, if the buffer became bigger than 10 MB)
                                        ret := management::ManageFileBuffer(bufferPath,10,fileSize);
                                        if not (ret) then return 0; endif;
                                else
                                        ! Get only information about the file, that is already in the buffer
                                        ret := storage::GetVersionInfo(versionID, path, bucket, getFileName, fileSize, dateCreated);
                                        if not (ret) then return 0; endif;
                        
                                        ret := FileCopy(bufferedFilePath,folder + "\\" + getFileName);
                                        if not (ret) then return 0; endif;
                                endif;
                        endif;
                        return 1;
                    }
                    Comment: "Add local buffer management to GetObjectVersion";
                    StringParameter versionID {
                        Property: Input;
                    }
                    StringParameter folder {
                        Property: Input;
                    }
                    StringParameter getFileName {
                        Property: Output;
                        InitialData: "";
                    }
                    Parameter ret;
                    StringParameter bufferPath;
                    StringParameter bufferedFilePath;
                    Parameter fileSize;
                    StringParameter bucket;
                    StringParameter path;
                    StringParameter dateCreated;
                }
                Procedure SetDefaultRequestDescription {
                    Arguments: (requestDescription);
                    Body: {
                        DefaultRequestDescription := requestDescription;
                        return 1;
                    }
                    StringParameter requestDescription {
                        Property: Input;
                    }
                }
            }
            Section Central_Storage {
                Procedure SaveFileToCentralStorage {
                    Arguments: (localPath,storagePath,authorization);
                    Body: {
                        ! Initialize PRO (if not initialized yet)
                        ret := Initialize();
                        if not HandleError(ret,"PROInitialize") then return 0; endif;
                        
                        !Sanity checking the existence of the local file
                        if not FileExists( localPath ) then
                                raise error "File '" + localPath + "' does not exist." ;
                                return 0 ;
                        endif ;
                        
                        !Determine the filename of the file we need to store. This means that we need
                        !to remove the absolute/relative path related part before the last / or \
                        localFileNameWithoutPath := FindReplaceStrings( localPath , "\\", "/" ) ;
                        if StringOccurrences( localFileNameWithoutPath , "/" ) then
                                localFileNameWithoutPath := substring( localFileNameWithoutPath ,
                                                                       FindNthString( localFileNameWithoutPath , "/", -1) + 1 ,
                                                                       StringLength(localFileNameWithoutPath ) ) ;
                        endif ;
                        
                        SplitStoragePath(storagePath,storageBucketPath,storageFileWithoutPath);
                        
                        !First try to create the necessary folder in central storage
                        ret := CreateStorageFolder(storageBucketPath,authorization);
                        if (not ret) then return 0; endif;
                        
                        !Now that we have created the required subbucket structure, we can now check if there already
                        !exists an object/file with the given name.
                        ret := storage::GetObjectInfo(storageBucketPath,storageFileWithoutPath, tmpLocalFileName, tmpType, tmpNum, tmpAuth, tmpVersion) ;
                        if ret and tmpNum>0 then ! Object versions exist
                                ret := storage::DeleteObjectAllVersions( storageBucketPath , storageFileWithoutPath ) ;
                                if not pro::HandleError(ret,"DeleteObjectAllVersions") then return 0; endif;
                        endif ;
                        
                        !Now store the local file into the bucket
                        ret := storage::PutObjectVersion( storageBucketPath, storageFileWithoutPath, localFileNameWithoutPath, authorization, tmpVersion ) ;
                        if not pro::HandleError(ret,"PutObjectVersion") then return 0; endif;
                        
                        return 1;
                    }
                    StringParameter localPath {
                        Property: Input;
                    }
                    StringParameter storagePath {
                        Property: Input;
                    }
                    StringParameter authorization {
                        Property: Optional;
                    }
                    StringParameter localFileNameWithoutPath;
                    StringParameter storageBucketPath;
                    StringParameter storageFileWithoutPath;
                    Parameter ret;
                    Parameter tmpNum;
                    StringParameter tmpAuth;
                    StringParameter tmpDate;
                    StringParameter tmpLocalFileName;
                    StringParameter tmpType;
                    StringParameter tmpVersion;
                }
                Procedure RetrieveFileFromCentralStorage {
                    Arguments: (storagePath,localPath);
                    Body: {
                        ! Initialize PRO (if not initialized yet)
                        ret := Initialize();
                        if not HandleError(ret,"PROInitialize") then return 0; endif;
                        
                        SplitStoragePath(storagePath, storageBucketPath, storageFileWithoutPath);
                        
                        !Now that we have created the required subbucket structure, we can now check if there already
                        !exists an object/file with the given name.
                        ret := storage::GetObjectInfo(storageBucketPath,storageFileWithoutPath, tmpLocalFileName, tmpType, tmpNum, tmpAuth, tmpVersion);
                        if ret then ! Object exists
                            ! retrieve file to temp folder
                            centralFolder := pro::PROTempFolder + "\\central";
                            if not DirectoryExists(centralFolder) then
                                DirectoryCreate(centralFolder);
                            endif;
                            ret := GetObjectVersion(tmpVersion, centralFolder, tmpLocalFileName);
                            if not pro::HandleError(ret,"GetObjectVersion") then return 0; endif;
                        
                            !Now that we have the file in the PROTempFolder, we move it to the destination folder and destination
                            !file name denoted by the arguments.
                            if not FileMove( centralFolder + "\\" + tmpLocalFileName, localPath ) then
                                    raise error "Error while moving file retrieved from server to destination folder: " + CurrentErrorMessage ;
                            endif ;
                        
                            return 1;
                        endif;
                        
                        return 0;
                    }
                    StringParameter storagePath {
                        Property: Input;
                    }
                    StringParameter localPath {
                        Property: Input;
                    }
                    StringParameter storageFileWithoutPath;
                    StringParameter storageBucketPath;
                    Parameter ret;
                    Parameter tmpNum;
                    StringParameter tmpAuth;
                    StringParameter tmpLocalFileName;
                    StringParameter tmpType;
                    StringParameter tmpVersion;
                    StringParameter centralFolder;
                }
                Procedure CreateStorageFolder {
                    Arguments: (storagePath,authorization);
                    Body: {
                        ! Initialize PRO (if not initialized yet)
                        ret := Initialize();
                        if not HandleError(ret,"PROInitialize") then return 0; endif;
                        
                        SplitStoragePath(storagePath, storageBucketPath, storageObjectWithoutPath);
                        
                        while (storageObjectWithoutPath) do
                            ! check if current path exists already
                            ret := storage::GetBucketInfo(storageBucketPath,storageObjectWithoutPath,tmpNum,tmpAuth,tmpDate);
                        
                            ! If ret = 1, we've found a parent bucket that exists, and we can start building from there.
                            ! Note, however, that the parent may not be writable so further errors may ensue when
                            ! trying to create additional folders.
                        
                            ! If the bucket itself does not exist or is not readable, then tmpNum = -1. In that case we should
                            ! still try to create the bucket. For existing buckets, tmpNum >= 0.
                        
                            if (not ret or tmpNum = -1) then
                                ! if the parent or bucket does not exist store the last part of the path for creation
                                Positions += card(Positions);
                                subBuckets(card(Positions)-1) := storageObjectWithoutPath;
                                storagePath := storageBucketPath;
                            endif;
                        
                            ! break from the loop when the parent does exist
                            break when ret;
                        
                            ! otherwise try again with the parent bucket one higher
                            SplitStoragePath(storagePath, storageBucketPath, storageObjectWithoutPath, 0);
                        endwhile;
                        
                        BucketsLeft := card(Positions);
                        while (BucketsLeft) do
                            ret := storage::CreateBucket(storagePath, SubBuckets(BucketsLeft-1), authorization);
                            if (not HandleError(ret, "CreateBucket")) then return 0; endif;
                        
                            storagePath += "/" + SubBuckets(BucketsLeft-1);
                            BucketsLeft -= 1;
                        endwhile;
                        
                        return 1;
                    }
                    StringParameter storagePath {
                        Property: Input;
                    }
                    StringParameter authorization {
                        Property: Optional;
                    }
                    StringParameter storageBucketPath;
                    StringParameter storageObjectWithoutPath;
                    Set Positions {
                        SubsetOf: Integers;
                        Index: iPosition;
                    }
                    StringParameter subBuckets {
                        IndexDomain: (iPosition);
                    }
                    StringParameter currentBucketPath;
                    Parameter ret;
                    Parameter tmpNum;
                    StringParameter tmpAuth;
                    StringParameter tmpDate;
                    Parameter BucketsLeft;
                }
                Procedure DeleteStorageFolder {
                    Arguments: (storagePath);
                    Body: {
                        ! Initialize PRO (if not initialized yet)
                        ret := Initialize();
                        if not HandleError(ret,"PROInitialize") then return 0; endif;
                        
                        NormalizeStoragePath(storagePath);
                        
                        ret := storage::DeleteBucket(storagePath);
                        if not pro::HandleError(ret,"DeleteBucket") then return 0; endif;
                        
                        return 1;
                    }
                    StringParameter storagePath {
                        Property: Input;
                    }
                    Parameter ret;
                }
                Procedure DeleteStorageFile {
                    Arguments: (storagePath);
                    Body: {
                        ! Initialize PRO (if not initialized yet)
                        ret := Initialize();
                        if not HandleError(ret,"PROInitialize") then return 0; endif;
                        
                        SplitStoragePath(storagePath, storageBucketPath, storageFileWithoutPath);
                        
                        ret := storage::DeleteObjectAllVersions(storageBucketPath,storageFileWithoutPath);
                        if not pro::HandleError(ret,"DeleteObjectAllVersions") then return 0; endif;
                        
                        return 1;
                    }
                    StringParameter storagePath {
                        Property: Input;
                    }
                    StringParameter storageFileWithoutPath;
                    StringParameter storageBucketPath;
                    Parameter ret;
                }
            }
        }
        Section Framework_Management {
            Section Public_Framework_Declarations {
                DeclarationSection Local_Configuration {
                    Set CommandLineArguments {
                        Index: CL;
                        Parameter: CommandLineArgument;
                        Property: NoSave;
                        Definition: {
                            data
                                { _pro-modelname    , _pro-modelversion , _pro-dll-directory, _pro-environment  , _pro-username     , _pro-logfile      ,
                                  _pro-tmpfolder    , _pro-endpoint     , _pro-language     , _pro-ticket       , _pro-secur        , _pro-session-id,
                                  _pro-webui-session-id   }
                        }
                    }
                    StringParameter ReadArguments {
                        IndexDomain: (CL);
                        Property: NoSave;
                    }
                    StringParameter PROConfigFile {
                        Property: NoSave;
                    }
                    StringParameter PROEnvironment {
                        Property: NoSave;
                    }
                    StringParameter PROUserName {
                        Property: NoSave;
                    }
                    StringParameter PROPassword {
                        Property: NoSave;
                    }
                    Set PROUserGroups {
                        Index: userGroup;
                        Property: NoSave;
                    }
                    StringParameter PROUserGroupName {
                        IndexDomain: (userGroup);
                        Property: NoSave;
                    }
                    StringParameter PROLastUserName {
                        Property: NoSave;
                    }
                    StringParameter PROLogConfigFile {
                        Property: NoSave;
                    }
                    StringParameter PROTempFolder {
                        Property: NoSave;
                    }
                    StringParameter PROEndPoint {
                        Property: NoSave;
                    }
                    Parameter PROLanguageCode {
                        IndexDomain: language;
                        Range: integer;
                        Property: NoSave;
                        Definition: data { English : 0 };
                    }
                    Parameter _PROLanguageCode {
                        Range: integer;
                        Default: 0;
                        Property: NoSave;
                    }
                    StringParameter PROAppCurrentDir {
                        Property: NoSave;
                    }
                }
                DeclarationSection Model_Fixed_Configuration {
                    Set ConfigIdentifiers {
                        SubsetOf: AllIdentifiers;
                        Property: NoSave;
                        Definition: data { 'pro::ModelName', 'pro::ModelVersion', 'pro::ModelDLLPath', 'pro::CurrentLanguage' };
                    }
                    StringParameter ModelName {
                        Property: NoSave;
                    }
                    StringParameter ModelVersion {
                        Property: NoSave;
                    }
                    StringParameter ModelDLLPath {
                        Property: NoSave;
                    }
                }
                Procedure HandleError {
                    Arguments: (ret,msg);
                    Body: {
                        if (not ret) then
                            ! Error prefix
                            if (msg <> "") then
                                msg := "Error at " + msg + ": ";
                            else
                                msg := "Error: ";
                            endif;
                        
                            ! Get error message in DLL
                            ret := management::GetLastError(errorCode,description);
                            if (not ret) then
                                msg += "Unknown";
                            else
                                msg += description;
                            endif;
                        
                                ! Display the error message in a proper way
                            if (IsRunningAtServer) then
                                management::LocalLogError(msg);
                            else
                                raise error msg code 'PRO-Framework' ;
                            endif;
                        
                                PROLastErrorMessage := msg;
                            return 0;
                        endif;
                        
                        PROLastErrorMessage := "";
                        return 1;
                    }
                    Parameter ret {
                        Property: Input;
                    }
                    Parameter errorCode {
                        Default: 0;
                        InitialData: 0;
                    }
                    StringParameter description {
                        Default: "";
                        InitialData: "";
                    }
                    StringParameter msg {
                        Default: "";
                        Property: Optional;
                    }
                }
                Procedure Initialize {
                    Arguments: (bufferSize);
                    Body: {
                        if (ProjectDeveloperMode and ModelName = "undefined" ) then
                                ! Initialization fails but does not further frustrate testing during PRO-enabling a project
                                raise warning "No model name, version or endpoint specified, trying to connect to PRO server during development will fail" ;
                                RETURN 0;
                        
                        ! Check if a critical error ocurred during library initialization
                        elseif PROCriticalError then
                                raise error "No model name or version specified, or no client DLL present (probably due to trying to connect to a PRO server from an unpublished model)" code 'PRO-Critical-initialization-error' ;
                                RETURN 0;
                        elseif (not CheckForNoEmpty) then
                                raise error "An apparent empty statement has been applied to the PRO library. This can result in undefined behavior" ;
                                RETURN 0;
                        endif;
                        
                        if (not ModelDLLPath and FileExists("pro_arguments.txt")) then
                                PROLoadClientConfiguration;
                        endif;
                        
                        ! Check if its already initialized
                        if (not management::IsInitialized()) then
                        
                                ! If there is a shared ticket, don't need user information
                                IF ReadArguments('_pro-ticket') = "" THEN
                                        ! Login information
                                        IF PROEnvironment = "" THEN PROEnvironment := "ROOT"; ENDIF;
                                        IF PROUserName = "" THEN PROUserName := "anonymous"; ENDIF;
                                        SetLogin;
                                        IF PROCancelLogin THEN
                                                RETURN 0;
                                        ELSEIF PROUserName = "" THEN
                                                raise error "Cannot connect to the PRO server with an empty user name." code 'PRO-Empty-username' ;
                                                RETURN 0;
                                        ENDIF;
                                        IF PROEnvironment = "" THEN
                                                PROEnvironment := "ROOT";
                                        ENDIF;
                        
                                        ! Collect user password info
                                        if (not IsRunningAtServer()) AND SessionHasVisibleGUI AND (PROPassword = "" OR PROUserName <> PROLastUserName) then
                                                DialogGetPassword("User Password",PROPassword,"AIMMS PRO Framework");
                                        endif;
                                ENDIF;
                        
                                ! Forward configuration to the DLL
                                tmpStr := ReadArguments('_pro-dll-directory');
                                if (not FileExists(PROLogConfigFile)) then
                                        GenerateDefaultLogConfigFile;
                                endif;
                                ret := management::Initialize(PROEndPoint,PROTempFolder,tmpStr,PROLogConfigFile,_PROLanguageCode,PROEnvironment,PROUserName,PROPassword);
                                if not HandleError(ret) then
                                        PROPassword := "";
                                        return 0;
                                else
                                        PROLastUserName := PROUserName;
                                endif;
                        
                                ! Startup arguments
                                PROSBufferSize := bufferSize;
                        
                                ret := authentication::GetCurrentUserGroupList(PROUserGroups, PROUserGroupName);
                        
                                GetListeningConnection(tmpStr);
                                if (not IsRunningAtServer()) then
                                        ! Reload session information ("Optimize Current Case" function)
                                        ret := session::InitializeManagedSessions;
                                endif;
                        
                                ! Initialize active session
                                session::ActiveSession := '';
                                session::LastKnowActiveSession := '';
                        
                                if not ret then return 0; endif;
                        endif;
                        
                        return 1;
                    }
                    Comment: "All public declarations in this section should be available after calling pro::Initialize";
                    Parameter ret {
                        InitialData: -1;
                    }
                    StringParameter tmpStr {
                        InitialData: "";
                    }
                    Parameter bufferSize {
                        Range: integer;
                        Default: 1;
                        Property: Optional;
                        Comment: "Usable amount of disk space (in Megabytes) to store files from PROS";
                    }
                }
                Function ListeningConnectionID {
                    Range: string;
                    Body: {
                        ListeningConnectionID := InternalListenConnectionID;
                    }
                }
                Procedure GetListeningConnection {
                    Arguments: (ConnectionID);
                    Body: {
                        if (management::IsConnected() and  InternalListenConnectionID <> "") then
                                ! Use already-stablished connection
                                ConnectionID := InternalListenConnectionID;
                                return 1;
                        else
                                return CreateListeningConnection(ConnectionID);
                        endif;
                    }
                    StringParameter ConnectionID {
                        Property: Output;
                        InitialData: "";
                    }
                    Parameter ret;
                }
            }
            Section Private_Tools {
                Parameter CheckForNoEmpty {
                    Property: NoSave;
                }
                Procedure DetermineProcedureName {
                    Arguments: (procedureName);
                    Body: {
                        ! If the user did not provide the name of the procedure, then first find it
                        ! using a little trick involving error handling
                        if procedureName = '' then
                            block
                                raise error "Artificial error induced by PRO Client library to detect procedure name in any of the delegation procedures" ;
                            onerror err do
                                ! To get the name of the procedure that actually called this procedure, we must
                                ! get the third node in the stacktrace.
                                procedureName := errh::Node( err, 3) ;
                                errh::MarkAsHandled(err,1) ;
                                CurrentErrorMessage := "";
                            endblock ;
                        endif ;
                    }
                    ElementParameter procedureName {
                        Range: AllProcedures;
                        Property: InOut;
                    }
                    ElementParameter err {
                        Range: errh::PendingErrors;
                    }
                }
                Procedure RunLocally {
                    Arguments: (delegationOverride);
                    Body: {
                        ! When running in the context of a server side session, use the delegation level
                        ! to determine whether to run locally or distribute further.
                        if (IsHandlingQueue(workerQueueID) and delegationOverride <= CurrentDelegationLevel) then
                            return 1;
                        endif;
                        
                        ! In developermode, we may want to run locally, or want to delegate to a server side session.
                        if ProjectDeveloperMode then
                            if (delegationOverride = 0 and not DeveloperModeDelegation) then
                                DeveloperModeDelegation := dialogAsk("Use PRO server for solving during this session?", "Yes", "No");
                            endif;
                        
                            if (DeveloperModeDelegation = 2) then
                                ! always run locally, so don't delegate
                                return 1;
                            else
                                ! set the delegationOverride level to 1, which is passed on to the
                                ! server side session, and is used there to determine whether to
                                ! solve locally there or further distribute a request.
                                delegationOverride := 1;
                                return 0;
                            endif;
                        endif ;
                        
                        ! Run remotely via PRO
                        return 0;
                    }
                    Parameter delegationOverride {
                        Default: 0;
                        Property: InOut;
                        Comment: {
                            " -1 : always run locally,
                               0 : ask if running in developer mode,
                            >= 1 : delegate if override level > level of current session"
                        }
                    }
                }
                Procedure IsHandlingQueue {
                    Arguments: (requestQueue);
                    Body: {
                        if (not requestQueue) then
                                return 0;
                        else
                                messaging::CurrentlyHandledQueue(CurrentlyHandledQueue);
                                return (CurrentlyHandledQueue = requestQueue);
                        endif;
                    }
                    StringParameter requestQueue {
                        Property: Input;
                    }
                    StringParameter CurrentlyHandledQueue;
                }
                Procedure GenerateDefaultLogConfigFile {
                    Body: {
                        put LogConfigFile;
                        put "# PRO global log configuration",/;
                        put "log4j.rootLogger=INFO, file",/;
                        put /;
                        put "# Write appender to file (max 50MB, at most 10 backup files)",/;
                        put "log4j.appender.file=org.apache.log4j.RollingFileAppender",/;
                        put "log4j.appender.file.file=AimmsPROClientLog.xml",/;
                        put "log4j.appender.file.ImmediateFlush=true",/;
                        put "log4j.appender.file.layout=org.apache.log4j.xml.XMLLayout",/;
                        put "log4j.appender.file.MaxFileSize=50MB",/;
                        put "log4j.appender.file.MaxBackupIndex=10",/;
                        put /;
                        put "# Special tracing for some loggers",/;
                        put "log4j.logger.PRO.FileTransfer=ERROR",/;
                        put "log4j.logger.ARMI=INFO",/;
                        putclose LogConfigFile;
                    }
                    File LogConfigFile {
                        Name: PROLogConfigFile;
                        Device: Disk;
                        Mode: replace;
                    }
                }
                Procedure PROLoadClientConfiguration {
                    Body: {
                        ! Read session command-line arguments (pair key-value)
                        CLIdx := 1;
                        empty ReadArguments;
                        WHILE CLIdx <= 20 and SessionArgument(CLIdx,CLArg) = 1 DO
                                CommandLineArgument := StringToElement(CommandLineArguments,CLArg);
                                IF CommandLineArgument <> '' THEN
                                        ! If it is a known key, check the value (next argument)
                                        CLIdx += 1;
                                        IF SessionArgument(CLIdx,CLArg) = 0 THEN
                                                ! No value informed for this key; assign "1"
                                                ReadArguments(CommandLineArgument) := "1";
                                                CLIdx -= 1;
                                        ELSEIF SubString(CLArg,1,5) = "_pro-" THEN
                                                ! The next argument is also a key; no value informed for this one, assign "1"
                                                ReadArguments(CommandLineArgument) := "1";
                                                CLIdx -= 1;
                                        ELSE
                                                ! Interpret key and value
                                                ReadArguments(CommandLineArgument) := CLArg;
                                        ENDIF;
                                ENDIF;
                                ! Check next pair (or next argument, in the case the last one was a invalid key)
                                CLIdx += 1;
                        ENDWHILE;
                        
                        !If the argument _pro-username is filled in, and neither _pro-session-id nor _pro-webui-session-id
                        !are set,this means it is very likely that we were started via the portal (otherwise, somebody has
                        !provided this manually as a CLI argument).
                        if (ReadArguments('_pro-username') and
                            ReadArguments('_pro-session-id') = "" and
                            ReadArguments('_pro-webui-session-id') = "")  then
                                if FileExists("pro_arguments.txt") then
                                        FileDelete("pro_arguments.txt") ;
                                endif ;
                        
                                !Ensure that we do not have any newlines, was problem ran into with longer path names
                                write ReadArguments to file "pro_arguments.txt" ;
                        endif ;
                        
                        !If you are running as developer, and the file exists, and no arguments have been provided, then
                        !use the file to read the information
                        if ProjectDeveloperMode and FileExists("pro_arguments.txt") and not ReadArguments('_pro-username') then
                                if FileExists("debug_arguments.txt") then
                                    retval := DialogAsk("Found server-side debug initialization file", "Setup server-side debug session", "Delete and start normal client session", title: "Run Mode");
                                    if ( retval = 1 ) then
                                        raise warning "Setting up server-side debug session" ;
                                        read from file "debug_arguments.txt" ;
                                        DebugServerSession := 1;
                                    else
                                        retval := 0;
                                    endif;
                                    ! A debug session can only be used once, so in any case we have to delete the file with debug arguments
                                    FileDelete("debug_arguments.txt");
                                endif;
                        
                                if (retval = 0) then
                                    raise warning "PRO - Not started via portal, reading PRO configuration from file" ;
                                    read from file "pro_arguments.txt" ;
                                    !And make sure that we empty the ticket, otherwise we will problems with shared tickets
                                endif;
                        
                                ReadArguments('_pro-ticket') := "";
                        endif ;
                        
                        ! Set the DLL file (if not provided, , uses the default "AimmsPROClient.dll")
                        IF ReadArguments('_pro-dll-directory') <> "" THEN
                                ModelDLLPath := ReadArguments('_pro-dll-directory') + "\\" + AimmsStringConstants('Architecture')+ "\\AimmsPROClient.dll";
                        ELSE
                                ReadArguments('_pro-dll-directory') := "AimmsProLibrary";
                                ModelDLLPath := "AimmsProLibrary\\" + AimmsStringConstants('Architecture')+ "\\AimmsPROClient.dll";
                        ENDIF;
                        
                        ! Create the temporary directory for internal use
                        IF ReadArguments('_pro-tmpfolder') <> "" THEN PROTempFolder := ReadArguments('_pro-tmpfolder'); ENDIF;
                        IF NOT DirectoryExists(PROTempFolder) THEN
                                DirectoryCreate(PROTempFolder);
                        ENDIF;
                        
                        ! Override local configuration with the command-line arguments
                        IF ReadArguments('_pro-modelname') <> "" THEN ModelName := ReadArguments('_pro-modelname'); ENDIF;
                        IF ReadArguments('_pro-modelversion') <> "" THEN ModelVersion := ReadArguments('_pro-modelversion'); ENDIF;
                        IF ReadArguments('_pro-environment') <> "" THEN PROEnvironment := ReadArguments('_pro-environment'); ENDIF;
                        IF ReadArguments('_pro-username') <> "" THEN PROUserName := ReadArguments('_pro-username'); ENDIF;
                        IF ReadArguments('_pro-logfile') <> "" THEN PROLogConfigFile := ReadArguments('_pro-logfile'); ENDIF;
                        IF ReadArguments('_pro-endpoint') <> "" THEN PROEndPoint := ReadArguments('_pro-endpoint'); ENDIF;
                        IF ReadArguments('_pro-language') <> "" THEN
                                IF StringToElement(AllLanguages,ReadArguments('_pro-language')) <> '' THEN
                                        CurrentLanguage := StringToElement(AllLanguages,ReadArguments('_pro-language'));
                                ENDIF;
                        ENDIF;
                        IF ReadArguments('_pro-session-id') <> "" THEN workerSessionID := ReadArguments('_pro-session-id'); ENDIF;
                        
                        RETURN 1;
                    }
                    Comment: {
                        "Read the parameters mandatory to the client, in the following order:
                        (1) Command-line arguments; (2) \"PROConf.xml\" in the root folder, if any; (3) \"PROConf.xml\" in the command-line
                        provided temp folder, if any; (4) \"PROConf.xml\" in \".\\temp\" folder, if any."
                    }
                    Parameter CLIdx {
                        Range: integer;
                        InitialData: 0;
                    }
                    StringParameter CLArg;
                    Parameter retval {
                        Default: 0;
                    }
                }
                Procedure NormalizeStoragePath {
                    Arguments: (storagePath);
                    Body: {
                        !Convert any \ character into a / character, as the rest of the code below will
                        !assume / as the separator.
                        storagePath := FindReplaceStrings( storagePath , "\\", "/" ) ;
                        
                        ! Strip any occurring 'PRO:' from the path
                        location := FindNthString(storagePath, "PRO:", 1, 0);
                        if (location) then
                            storagePath := SubString(storagePath, location + 4, StringLength(storagePath));
                        endif;
                        
                        !Now remove all leading and trailing / characters.
                        while SubString( storagePath , 1, 1) = "/" do
                                storagePath := SubString( storagePath, 2 , StringLength( storagePath ) ) ;
                        endwhile ;
                        
                        while SubString( storagePath , -1, -1) = "/" do
                                storagePath := SubString( storagePath, 1 , StringLength( storagePath ) -1 ) ;
                        endwhile ;
                        
                        !And just (re-)add just one leading /
                        storagePath := "/" + storagePath ;
                    }
                    StringParameter storagePath {
                        Property: InOut;
                    }
                    Parameter location;
                }
                Procedure SplitStoragePath {
                    Arguments: (storagePath,storageBucketPath,storageFileWithoutPath,normalize);
                    Body: {
                        if (normalize) then
                            NormalizeStoragePath(storagePath)
                        endif;
                        
                        !Retrieve the bucket path
                        storageBucketPath := SubString(storagePath,1,FindNthString( storagePath, "/", -1 ) - 1) ;
                        
                        !And retrieve the storage file name
                        storageFileWithoutPath := SubString( storagePath,
                                                             FindNthString(storagePath,"/",-1) + 1 ,
                                                             StringLength(storagePath) ) ;
                    }
                    StringParameter storagePath {
                        Property: InOut;
                    }
                    StringParameter storageBucketPath {
                        Property: Output;
                    }
                    StringParameter storageFileWithoutPath {
                        Property: Output;
                    }
                    Parameter normalize {
                        Default: 1;
                        Property: Optional;
                    }
                }
            }
            Section Listening_Connection {
                StringParameter InternalListenConnectionID {
                    Property: NoSave;
                }
                Procedure ListenCallBack {
                    Arguments: (queue,refNumber,callType);
                    Comment: "Callback that gets called right before handling every incoming message. Useful for debugging and logging purposes.";
                    StringParameter queue {
                        Property: Input;
                    }
                    Parameter refNumber {
                        Range: integer;
                        Property: Input;
                    }
                    Parameter callType {
                        Range: integer;
                        Property: Input;
                    }
                }
                Procedure CreateListeningConnection {
                    Arguments: (ConnectionID);
                    Body: {
                        if (not management::IsInitialized()) then
                                !DialogMessage("PRO Framework not initialized", "PRO Framework");
                                raise error "PRO Framework not initialized" code 'PRO-Not-initialized' ;
                                ret := 0;
                        elseif (management::IsConnected() and  InternalListenConnectionID <> "") then
                                ! Use already-stablished connection
                                ConnectionID := InternalListenConnectionID;
                                ret := 1;
                        else
                                ! Listen to a new connection
                                ret := messaging::CreateConnection(InternalListenConnectionID,'pro::ListenCallBack');
                                if not HandleError(ret) then return 0; endif;
                                ConnectionID := InternalListenConnectionID;
                        endif;
                        
                        return ret;
                    }
                    StringParameter ConnectionID {
                        Property: Output;
                        InitialData: "";
                    }
                    Parameter ret;
                }
                Procedure CloseListeningConnection {
                    Body: {
                        ! Close PRO-managed connections
                        if (management::IsConnected()) then
                            ret := messaging::TerminateConnection(InternalListenConnectionID);
                            if ret then return 0; endif;
                        endif;
                        
                        InternalListenConnectionID := "";
                        return 1;
                    }
                    Parameter ret;
                }
            }
            Section Worker_Setup {
                DeclarationSection Worker_State {
                    StringParameter clientQueueID {
                        Property: NoSave;
                    }
                    StringParameter workerQueueID {
                        Property: NoSave;
                    }
                    StringParameter workerSessionID {
                        Property: NoSave;
                    }
                    Parameter workerDelegationLevel {
                        Property: NoSave;
                    }
                    Parameter openedAsWorker {
                        Range: binary;
                        Default: 0;
                        Property: NoSave;
                        Definition: 1 $ workerSessionID;
                    }
                    Parameter workerCallbackCalled {
                        Property: NoSave;
                    }
                }
                DeclarationSection Worker_Trace_Info {
                    StringParameter workerErrorMsg {
                        Property: NoSave;
                        Comment: "Don\'t have the NoSave flag because it can be informed from worker to client.";
                    }
                }
                DeclarationSection Worker_Request_Info {
                    StringParameter workerRequestClientRef {
                        Property: NoSave;
                    }
                    StringParameter workerRequestDescription {
                        Property: NoSave;
                    }
                    StringParameter workerRequestProcedure {
                        Property: NoSave;
                    }
                    Parameter workerRequestTimeout {
                        Property: NoSave;
                    }
                    StringParameter workerInputDataVersion {
                        Property: NoSave;
                    }
                    StringParameter workerOutputDataVersion {
                        Property: NoSave;
                    }
                    StringParameter workerLogFileVersion {
                        Property: NoSave;
                    }
                    StringParameter workerErrorMessage {
                        Property: NoSave;
                    }
                    Parameter workerActiveStatus {
                        Property: NoSave;
                    }
                    Parameter workerErrorCode {
                        Property: NoSave;
                    }
                }
                Procedure PublishingVerification {
                    Body: {
                        ! Check if DLL exists
                        IF NOT FileExists(ModelDLLPath) THEN
                                return -1;
                        ! Check if the DLL responds to a call
                        ELSEIF NOT management::LocalLogInfo("Test Publishing...") THEN
                                return -2;
                        ELSEIF NOT StringToElement(AllIdentifiers, "MainInitialization") THEN
                                return -3;
                        ENDIF;
                        
                        ! System OK
                        RETURN PROP_LIBPRJ_OK;
                    }
                }
                Procedure PROWorkerHandleError {
                    Arguments: (ret);
                    Body: {
                        if (not ret) then
                                ret := management::GetLastError(errorCode,description);
                                if (not ret) then
                                        workerErrorMsg := "Unknown Error";
                                else
                                        workerErrorMsg := description;
                                endif;
                                return 0;
                        endif;
                        return 1;
                    }
                    Parameter ret {
                        Range: integer;
                        Property: Input;
                    }
                    Parameter errorCode {
                        Default: 0;
                        InitialData: 0;
                    }
                    StringParameter description {
                        Default: "";
                        InitialData: "";
                    }
                }
                Procedure PROWorkerInitialization {
                    Body: {
                        ! Check if LibraryInitialization was already run
                        if (not PROLibraryInit) then
                                LibraryInitialization;
                        endif;
                        
                        ! If PRO is not initialized, start it
                        if (not management::IsInitialized()) then
                            tmpStr := ReadArguments('_pro-dll-directory');
                            if (DebugServerSession AND SessionHasVisibleGUI AND PROPassword = "")  then
                                DialogGetPassword("Password for user " + PROUserName,PROPassword,"AIMMS PRO Framework");
                            endif;
                            ret := management::Initialize(PROEndPoint,PROTempFolder,tmpStr,PROLogConfigFile,_PROLanguageCode,PROEnvironment,PROUserName,PROPassword);
                            if not PROWorkerHandleError(ret) then return 0; endif;
                        endif;
                        
                        management::LocalLogInfo("Worker Initialization: session " + workerSessionID);
                        
                        ret := PROWorkerRetrieveRequestInfo;
                        if not PROWorkerHandleError(ret) then return 0; endif;
                        
                        ret := sessionmanager::SetSessionReference(workerSessionID,clientQueueID,workerQueueID);
                        if not PROWorkerHandleError(ret) then return 0; endif;
                        
                        ret := PROWorkerListen;
                        return ret;
                    }
                    StringParameter tmpStr;
                    Parameter ret;
                }
                Procedure PROWorkerFinalization {
                    Body: {
                        if (not workerCallbackCalled) then
                            pro::SessionCompletedCallBackProxy(workerSessionID);
                        endif;
                    }
                }
                Procedure PROWorkerListen {
                    Body: {
                        if (management::IsInitialized()) then
                                ret := GetListeningConnection(connectionID);
                                if not PROWorkerHandleError(ret) then return 0; endif;
                                ret := messaging::AddQueueToConnection(workerQueueID, connectionID);
                                if not PROWorkerHandleError(ret) then return 0; endif;
                        endif;
                        return 1;
                    }
                    Parameter ret;
                    StringParameter connectionID;
                }
                Procedure PROWorkerRetrieveRequestInfo {
                    Body: {
                        SetElementAdd(_Sessions, _Session, workerSessionId);
                        
                        ret := sessionmanager::RetrieveSessionList(_Sessions, _ClientQueueID, _WorkerQueueID, _LastKnownStatus, _RequestTime, _UserEnv,
                                        _UserName, _Application, _OriginalCasePath, _RequestDescription, _RequestProcedure,
                                        _RunTimeOut, _VersionID, _ResponseVersionID, _MessageLogVersionID,
                                        _ErrorMessage, _ActiveStatus, _ErrorCode);
                        if not PROWorkerHandleError(ret) then return 0; endif;
                        
                        clientQueueID := _ClientQueueID(_Session);
                        workerQueueID := _WorkerQueueID(_Session);
                        workerRequestClientRef := _OriginalCasePath(_Session);
                        workerRequestDescription := _RequestDescription(_Session);
                        workerRequestProcedure := _RequestProcedure(_Session);
                        workerRequestTimeout := _RunTimeOut(_Session);
                        workerInputDataVersion := _VersionID(_Session);
                        workerOutputDataVersion := _ResponseVersionID(_Session);
                        workerLogFileVersion := _MessageLogVersionID(_Session);
                        workerErrorMessage := _ErrorMessage(_Session);
                        workerActiveStatus := _ActiveStatus(_Session);
                        workerErrorCode := _ErrorCode(_Session);
                        
                        return 1;
                    }
                    Parameter ret;
                    Set _Sessions {
                        Index: sess;
                        Parameter: _Session;
                    }
                    StringParameter _ClientQueueID {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _WorkerQueueID {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    Parameter _LastKnownStatus {
                        IndexDomain: sess;
                        Default: 0;
                    }
                    StringParameter _RequestTime {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _UserEnv {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _UserName {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _Application {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _OriginalCasePath {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _RequestDescription {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _RequestProcedure {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    Parameter _RunTimeOut {
                        IndexDomain: sess;
                        Default: 0;
                    }
                    StringParameter _VersionID {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _ResponseVersionID {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _MessageLogVersionID {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    StringParameter _ErrorMessage {
                        IndexDomain: sess;
                        InitialData: "";
                    }
                    Parameter _ActiveStatus {
                        IndexDomain: sess;
                        Default: 0;
                    }
                    Parameter _ErrorCode {
                        IndexDomain: sess;
                        Default: 0;
                    }
                }
                Procedure PROWorkerSaveRequestInfo {
                    Body: {
                        return sessionmanager::SetRequestInfo(workerSessionID,
                                workerRequestClientRef, workerRequestDescription, workerRequestProcedure, workerRequestTimeout,
                                workerInputDataVersion, workerOutputDataVersion, workerLogFileVersion, workerErrorMessage,
                                workerActiveStatus, workerErrorCode);
                    }
                }
                Procedure SessionCompletedCallBackProxy {
                    Arguments: (RequestID);
                    Body: {
                        ret := client::SendRunProcedure(
                                pro::clientQueueID,
                                'pro::session::SessionCompletedCallBack',
                                'pro::session::SessionCompletedCallBackProxy',
                                -1,
                                PROMFLAG_SESSION + PROMFLAG_RESPONSE
                        );
                        HandleError(ret);
                        
                        return ret;
                    }
                    StringParameter RequestID {
                        Property: Input;
                    }
                    Parameter ret;
                }
            }
            Section Localization {
                Set AllLanguages {
                    Index: language;
                    Parameter: CurrentLanguage;
                    Property: NoSave;
                    OrderBy: User;
                    Definition: Data { English };
                    Comment: {
                        "This set should contain all languages for which you want to
                        localize your AIMMS end-user application. You can add new
                        languages at any time. However, you should always make sure
                        that your development language remains the first language
                        in the set. AIMMS will use this language to create new
                        localization entries during the automated localization
                        procedure as well as in the localization wizards."
                    }
                }
                Set LocalizedTextIndexSet {
                    SubsetOf: Integers;
                    Index: lti;
                    Property: NoSave;
                    Definition: Data { 1 .. 5 };
                    Comment: {
                        "This set is used to number all localized strings in your
                        end-user interface. The localization wizards automatically
                        update the definition of this set whenever new localization
                        strings are added. Therefore, you should not edit the
                        definition of this set by hand, unless you are sure
                        what you are doing."
                    }
                }
                StringParameter LocalizedText {
                    IndexDomain: (lti,language);
                    Property: NoSave;
                    Comment: {
                        "This string parameter contains the actual localized strings
                        that are visible in the end-user interface. You can edit its
                        contents in the `Localized Text` window, which is accessible
                        through the `Tools-Localization` menu. The `Localized Text`
                        window is also opened when you invoke the `Data ...` menu
                        for any of the localization identifiers."
                    }
                }
                StringParameter LocalizedTextDescription {
                    IndexDomain: (lti);
                    Property: NoSave;
                    Comment: {
                        "This string parameter contains an (optional) description for
                        each localization string. You can edit its contents in the
                        `Localized Text` window, which is accessible through the
                        `Tools-Localization` menu. The `Localized Text` window is
                        also opened when you invoke the `Data ...` menu for any of
                        the localization identifiers."
                    }
                }
                Procedure LocalizationReadLanguage {
                    Arguments: ThisLanguage;
                    Body: {
                        LanguageFileName := FormatString("<lib:pro>:Localization\\%e.txt", ThisLanguage );
                        
                        if FileExists( LanguageFileName ) then
                            Read From File LanguageFileName;
                        endif;
                    }
                    Comment: "This procedure reads the localization data for a single language.";
                    ElementParameter ThisLanguage {
                        Range: AllLanguages;
                        Property: Input;
                    }
                    StringParameter LanguageFileName;
                }
                Procedure LocalizationWriteLanguage {
                    Arguments: ThisLanguage;
                    Body: {
                        if ( ProjectDeveloperMode and
                             Count( lti | LocalizedText(lti,ThisLanguage) ) ) then
                        
                            LanguageFileName := FormatString("<lib:pro>:Localization\\%e.txt", ThisLanguage );
                            put f;
                            display LocalizedText(lti,ThisLanguage);
                            putclose;
                        
                        endif;
                    }
                    Comment: {
                        "This procedure writes the localization data for a single language.
                        AIMMS will only write data, if data for the language is actually
                        present. This will prevent loss of localization data which is
                        written without being read before."
                    }
                    ElementParameter ThisLanguage {
                        Range: AllLanguages;
                        Property: Input;
                    }
                    StringParameter LanguageFileName;
                    File f {
                        Name: LanguageFileName;
                        Device: Disk;
                        Mode: replace;
                    }
                }
                Procedure LocalizationReadAll {
                    Body: {
                        for ( language ) do
                            LocalizationReadLanguage( language );
                        endfor;
                        
                        if ( ProjectDeveloperMode and
                             FileExists("<lib:pro>:Localization\\Descriptions.txt") ) then
                            read from file "<lib:pro>:Localization\\Descriptions.txt";
                        endif;
                    }
                    Comment: {
                        "Execute this procedure if you intend to edit the localization
                        parameters by hand (i.e. without using the localization wizards).
                        In that case, do not forget to call LocalizationWriteAll before
                        the end of your AIMMS session."
                    }
                }
                Procedure LocalizationWriteAll {
                    Body: {
                        for ( language ) do
                            LocalizationWriteLanguage( language );
                        endfor;
                        
                        if ( ProjectDeveloperMode and
                             Count( lti | LocalizedTextDescription(lti) ) ) then
                        
                            write LocalizedTextDescription to file "<lib:pro>:Localization\\Descriptions.txt";
                        
                        endif;
                    }
                    Comment: {
                        "You should execute this procedure if you have edited the
                        localization parameters by hand. Before editing, you can
                        call LocalizationReadAll to obtain all currently present
                        localization data."
                    }
                }
                Procedure LocalizationInitialize {
                    Body: {
                        if not CurrentLanguage then
                            CurrentLanguage := first(AllLanguages);
                        endif;
                        
                        LocalizationReadLanguage(CurrentLanguage);
                    }
                    Comment: {
                        "This procedure initializes localization support for your application.
                        It is automatically added to the end of MainInitialization during the
                        localization setup. If the element parameter CurrentLanguage already
                        has been assigned a value at that time, AIMMS will read the localization
                        strings for that language. In all other cases, the localization data
                        for the development language is read."
                    }
                }
            }
            Section Developer_GUI {
                Procedure SetLogin {
                    Body: {
                        IF SessionHasVisibleGUI THEN
                                PROCancelLogin := 0;
                                PageOpen("Login");
                        ENDIF;
                    }
                }
            }
            DeclarationSection General_Declarations {
                StringParameter PROS_ROOT_USER_BUCKET {
                    Property: NoSave;
                    Definition: "UserData";
                }
                Parameter PROP_LIBPRJ_OK {
                    Range: integer;
                    Property: NoSave;
                    Definition: 42577;
                    Comment: "Key Code for Publishing: 0xA651";
                }
                StringParameter PROLastErrorMessage {
                    Property: NoSave;
                }
                Parameter PROSBufferSize {
                    Range: integer;
                    Default: 1;
                    Property: NoSave;
                }
            }
            DeclarationSection Startup_and_Login {
                Parameter PROLibraryInit {
                    Range: binary;
                    Default: 0;
                    Property: NoSave;
                }
                Parameter PROCriticalError {
                    Range: binary;
                    Default: 0;
                    Property: NoSave;
                }
                Parameter PROCancelLogin {
                    Range: binary;
                    Default: 0;
                    Property: NoSave;
                }
            }
            Procedure Finalize {
                Body: {
                    ! Finalize connection with PRO server
                    if management::IsInitialized() then
                        ret := CloseListeningConnection;
                        ! Don't check the return value, because we want management::Finalize to be callled at this stage
                    
                        ret := management::Finalize();
                        ! Don't check the return value here, because want the Temp folder to be deleted at this stage
                    endif;
                    
                    if DirectoryExists(PROTempFolder) then
                            DirectoryDelete(PROTempFolder);
                    endif;
                    
                    session::ActiveSession := '';
                    return 1;
                }
                Parameter ret {
                    InitialData: -1;
                }
            }
        }
        Module Managed_Sessions {
            Prefix: session;
            Section Public_Declarations {
                Set sessionsToRemove {
                    Parameter: sessionToRemove;
                    InitialData: data { };
                }
                StringParameter warnString;
                Parameter ActiveSessionRunning {
                    Property: NoSave;
                    Definition: 1 $ (ActiveSession and LastKnownStatus(ActiveSession) < PROTS_FINISHED);
                }
                StringParameter LastKnownActiveSessionStatus {
                    Property: NoSave;
                    Definition: {
                        if(LastKnownStatus(LastKnowActiveSession) = 0) then
                        "Created"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 1) then
                        "Queued"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 2) then
                        "Starting server session"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 3) then
                        "Waiting for tasks"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 4) then
                        "Running"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 5) then
                        "Closing server session"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 6) then
                        "Finished"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 7) then
                        "Terminated"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 8) then
                        "Finished with errors"
                        elseif(LastKnownStatus(LastKnowActiveSession) = 9) then
                        "Deleted"
                        else
                        "Unknown"
                        endif
                    }
                }
                Parameter RetainSessionCases {
                    Default: 0;
                    Property: NoSave;
                }
                Parameter SaveSessionMessages {
                    Default: 1;
                    Property: NoSave;
                }
                DeclarationSection Managed_Session_Data {
                    Set ManagedSessions {
                        Index: manSess;
                        Parameter: ManagedSession, LastStartedSession, ActiveSession, LastKnowActiveSession;
                        Property: NoSave;
                    }
                    Set ManagedSessionsActive {
                        SubsetOf: ManagedSessions;
                        Index: msAct;
                        Parameter: ManagedSessionActive;
                        Property: NoSave;
                    }
                    Set ManagedSessionsFinished {
                        SubsetOf: ManagedSessions;
                        Index: msFinish;
                        Parameter: ManagedSessionInactive;
                        Property: NoSave;
                        Definition: ManagedSessions - ManagedSessionsActive;
                    }
                    StringParameter BucketBasePath {
                        Property: NoSave;
                        Definition: GetPROSUserBucket + "/ManagedSessions_" + ModelName + "_" + ModelVersion;
                    }
                    Parameter MaxInitTimeout {
                        Default: 60000;
                        Property: NoSave;
                    }
                    Parameter MaxCloseTimeout {
                        Default: 30000;
                        Property: NoSave;
                    }
                    StringParameter ClientQueueID {
                        IndexDomain: manSess;
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter WorkerQueueID {
                        IndexDomain: manSess;
                        Property: NoSave;
                        InitialData: "";
                    }
                    Parameter LastKnownStatus {
                        IndexDomain: (manSess);
                        Default: 0;
                        Property: NoSave;
                    }
                    StringParameter RequestTime {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter UserEnv {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter UserName {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter Application {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter OriginalCasePath {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter RequestDescription {
                        IndexDomain: manSess;
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter RequestProcedure {
                        IndexDomain: manSess;
                        Property: NoSave;
                        InitialData: "";
                    }
                    Parameter RunTimeOut {
                        IndexDomain: (manSess);
                        Default: 0;
                        Property: NoSave;
                    }
                    StringParameter VersionID {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter ResponseVersionID {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter MessageLogVersionID {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    StringParameter ErrorMessage {
                        IndexDomain: (manSess);
                        Property: NoSave;
                        InitialData: "";
                    }
                    Parameter ActiveStatus {
                        IndexDomain: (manSess);
                        Default: 0;
                        Property: NoSave;
                    }
                    Parameter ErrorCode {
                        IndexDomain: (manSess);
                        Default: 0;
                        Property: NoSave;
                    }
                }
                Section Hooks_and_Callbacks {
                    ElementParameter PostLoadInputCaseHook {
                        Range: AllProcedures;
                        Default: 'pro::session::AuxEmpty';
                        Property: NoSave;
                    }
                    ElementParameter PostLoadResultCaseHook {
                        Range: AllProcedures;
                        Default: 'pro::session::AuxEmpty';
                        Property: NoSave;
                    }
                    ElementParameter ServerErrorCallBackHook {
                        Range: AllProcedures;
                        Default: 'pro::session::EmptyCallBack';
                        Property: NoSave;
                    }
                    Procedure DefaultCallBack {
                        Arguments: (RequestID);
                        Body: {
                            ! Notify the user discretely
                            SessionElement := StringToElement(ManagedSessions,RequestID);
                            tmpStr := "*** " + CurrentToString("%H:%M:%S") + " - New request result available: '" + RequestDescription(SessionElement) + "'! Check Request Manager! ***";
                            StatusMessage(tmpStr);
                        }
                        ElementParameter SessionElement {
                            Range: ManagedSessions;
                        }
                        StringParameter tmpStr {
                            InitialData: "";
                        }
                        StringParameter RequestID {
                            Property: Input;
                        }
                    }
                    Procedure LoadResultsCallBack {
                        Arguments: (RequestID);
                        Body: {
                            !Automatically load the results
                            SessionElement := StringToElement(session::ManagedSessions,RequestID);
                            
                            version::ResetCaseStatus();
                            
                            ! Get the message log and the case file from the Storage Service
                            cbFolder := PROTempFolder + "\\callback";
                            if not DirectoryExists(cbFolder) then
                                DirectoryCreate(cbFolder);
                            endif;
                            
                            if MessageLogVersionID(SessionElement) <> "" then
                                ret := GetObjectVersion(MessageLogVersionID(SessionElement),cbFolder,tmpFileLog);
                                if not HandleError(ret) then return 0; endif;
                            endif;
                            
                            if (ResponseVersionID(SessionElement)) then
                                ret := GetObjectVersion(ResponseVersionID(SessionElement),cbFolder,tmpFile);
                                if not HandleError(ret) then return 0; endif;
                            
                                ! Load file
                                ret := version::LoadCaseByFile(cbFolder + "\\" + tmpFile);
                            
                                if not ret then
                                    DialogMessage("Error during load. File corrupted.", "PRO Framework - Load Solution");
                                    return 0;
                                endif;
                            
                                Apply(PostLoadResultCaseHook);
                            endif;
                        }
                        ElementParameter SessionElement {
                            Range: ManagedSessions;
                        }
                        StringParameter tmpStr {
                            InitialData: "";
                        }
                        StringParameter RequestID {
                            Property: Input;
                        }
                        Parameter ret;
                        StringParameter tmpFile {
                            InitialData: "";
                        }
                        StringParameter tmpFileLog {
                            InitialData: "";
                        }
                        StringParameter cbFolder;
                    }
                    Procedure EmptyCallBack {
                        Arguments: (RequestID);
                        Body: {
                            ! Does nothing
                        }
                        StringParameter RequestID {
                            Property: Input;
                        }
                    }
                    Procedure SessionCompletedCallBack {
                        Arguments: (RequestID);
                        Body: {
                            ! Does nothing
                        }
                        StringParameter RequestID {
                            Property: Input;
                        }
                    }
                    Procedure ServerErrorCallBack {
                        Arguments: (RequestID);
                        Body: {
                            OptimizationCallBack(ServerErrorCallBackHook, RequestID);
                            
                            SessionElement := StringToElement(session::ManagedSessions,RequestID);
                            if (SessionElement) then
                                    LastKnownStatus(SessionElement) := PROTS_ERROR;
                            endif;
                        }
                        ElementParameter SessionElement {
                            Range: ManagedSessions;
                        }
                        StringParameter RequestID {
                            Property: Input;
                        }
                    }
                }
                Procedure LoadManagedSessions {
                    Body: {
                        ! Collect a tree of data: session-list-container with all session references (level 1), and session properties (level 2)
                        
                        ret := sessionmanager::ListActiveSessions(CheckRequests,
                                        ClientQueueID, WorkerQueueID, LastKnownStatus, RequestTime, UserEnv,
                                        UserName, Application, OriginalCasePath, RequestDescription, RequestProcedure,
                                        RunTimeOut, VersionID, ResponseVersionID, MessageLogVersionID,
                                        ErrorMessage, ActiveStatus, ErrorCode, 0 /*allUsers*/, ModelName, "" /*projectId*/);
                        
                        if not HandleError(ret) then return 0; endif;
                        
                        ! Collect the request status
                        if Card(CheckRequests) > 0 then
                                GetListeningConnection(tmpConnection);
                                ! Check que session status
                                ret := sessionmanager::CurrentState(ManagedSessions,LastKnownStatus);
                                if not HandleError(ret) then return 0; endif;
                        
                                ! Clear data for already-finished sessions
                                for (msCheck | LastKnownStatus(msCheck) >= PROTS_CLOSING) do
                                        ! Check the incoming queue status
                                        ret := messaging::GetQueueInfo(ClientQueueID(msCheck),tmpVal,tmpVal2);
                                        if not HandleError(ret) then return 0; endif;
                        
                                        ! Set the status to inactive if there are no more messages
                                        if (tmpVal = 0) then
                                                ActiveStatus(msCheck) := 0;
                                                sessionmanager::SetRequestInfo(msCheck, OriginalCasePath(msCheck), RequestDescription(msCheck),
                                                        RequestProcedure(msCheck), RunTimeOut(msCheck), VersionID(msCheck),
                                                        ResponseVersionID(msCheck), MessageLogVersionID(msCheck),
                                                        ErrorMessage(msCheck), ActiveStatus(msCheck), ErrorCode(msCheck));
                                                if (msCheck in ManagedSessionsActive) then
                                                    messaging::RemoveQueueFromConnection(ClientQueueID(msCheck), tmpConnection);
                                                    ManagedSessionsActive -= msCheck;
                                                endif;
                                        endif;
                                endfor;
                        
                                ! Add all sessions queued and running to the set of active sessions on the queues of which we actively listen
                                for (msCheck | LastKnownStatus(msCheck) <= PROTS_RUNNING) do
                                        if (not msCheck in ManagedSessionsActive) then
                                                ret := messaging::AddQueueToConnection(ClientQueueID(msCheck), tmpConnection);
                                                if not HandleError(ret) then skip; endif;
                                                ManagedSessionsActive += msCheck;
                                        endif;
                                endfor;
                        endif;
                        
                        
                        return 1;
                    }
                    Parameter ret {
                        InitialData: -1;
                    }
                    StringParameter tmpStr;
                    Parameter tmpVal {
                        InitialData: 0;
                    }
                    Parameter tmpVal2 {
                        InitialData: 0;
                    }
                    StringParameter tmpContActive {
                        InitialData: "";
                    }
                    StringParameter tmpContInactive {
                        InitialData: "";
                    }
                    Set Containers {
                        Index: CONT, CONT2;
                        Parameter: Container, Container2;
                    }
                    Set Items {
                        Index: ITEM, ITEM2;
                    }
                    StringParameter Value {
                        IndexDomain: (CONT,ITEM);
                    }
                    ElementParameter Ref {
                        IndexDomain: (CONT,ITEM);
                        Range: Containers;
                    }
                    Set ClosedRequests {
                        SubsetOf: ManagedSessions;
                        Index: RRS_CLOSED;
                    }
                    Set CheckRequests {
                        SubsetOf: ManagedSessions;
                        Index: msCheck;
                    }
                    StringParameter tmpConnection;
                }
                Procedure SetSessionData {
                    Arguments: (session,description,clientQueue,workerQueue,procedureName,_runTimeout,_versionId,_responseVersionId,_messageLogVersionId,_currentErorrMessage,_requestTime,_originalCasePath);
                    Body: {
                        ManagedSession := StringToElement(ManagedSessions,session);
                        if ManagedSession = '' then
                                ! Not stored locally yet
                                SetElementAdd(ManagedSessions,ManagedSession,session);
                        endif;
                        
                        RequestDescription(ManagedSession) := description;
                        ClientQueueID(ManagedSession) := clientQueue;
                        WorkerQueueID(ManagedSession) := workerQueue;
                        RequestProcedure(ManagedSession) := procedureName;
                        RunTimeOut(ManagedSession) := _runTimeout;
                        VersionID(ManagedSession) := _versionId;
                        ResponseVersionID(ManagedSession) := _responseVersionId;
                        MessageLogVersionID(ManagedSession) := _messageLogVersionId;
                        ErrorMessage(ManagedSession) := _currentErorrMessage;
                        RequestTime(ManagedSession) := _requestTime;
                        OriginalCasePath(ManagedSession) := _originalCasePath;
                    }
                    StringParameter description {
                        Property: Input;
                    }
                    StringParameter clientQueue {
                        Property: Input;
                    }
                    StringParameter workerQueue {
                        Property: Input;
                    }
                    StringParameter procedureName {
                        Property: Input;
                    }
                    Parameter _runTimeout {
                        Property: Input;
                    }
                    StringParameter _versionId {
                        Property: Input;
                    }
                    StringParameter _responseVersionId {
                        Property: Input;
                    }
                    StringParameter _messageLogVersionId {
                        Property: Input;
                    }
                    StringParameter _currentErorrMessage {
                        Property: Input;
                    }
                    StringParameter _requestTime {
                        Property: Input;
                    }
                    StringParameter _originalCasePath {
                        Property: Input;
                    }
                    StringParameter session {
                        Property: Input;
                    }
                }
                Procedure SetActiveSession {
                    Arguments: (session);
                    Body: {
                        if (session) then
                                ActiveSession := StringToElement(ManagedSessions, session);
                                LastKnowActiveSession := ActiveSession;
                        else
                                ActiveSession := '';
                        endif;
                    }
                    StringParameter session {
                        Property: Input;
                    }
                }
                Procedure RemoveManagedSession {
                    Arguments: (session);
                    Body: {
                        ManagedSession := StringToElement(ManagedSessions,session);
                        if (ManagedSession) then
                                ManagedSessions -= ManagedSession;
                        endif;
                    }
                    StringParameter session {
                        Property: Input;
                    }
                }
                Function CurrentSession {
                    Range: ManagedSessions;
                    Body: {
                        CurrentSession := LastStartedSession;
                    }
                }
                Function CurrentClientQueue {
                    Range: string;
                    Body: {
                        CurrentClientQueue := ClientQueueID(LastStartedSession);
                    }
                }
                Function CurrentSessionQueue {
                    Range: string;
                    Body: {
                        CurrentSessionQueue := WorkerQueueID(LastStartedSession);
                    }
                }
                Function CurrentSessionStatus {
                    Body: {
                        CurrentSessionStatus := LastKnownStatus(LastStartedSession);
                    }
                }
                Function CurrentInputCaseID {
                    Range: string;
                    Body: {
                        CurrentInputCaseID := VersionID(LastStartedSession);
                    }
                }
                Function CurrentOutputCaseID {
                    Range: string;
                    Body: {
                        CurrentOutputCaseID := ResponseVersionID(LastStartedSession);
                    }
                }
            }
            Procedure RunManagedSession {
                Arguments: {
                    (ClientQueue,WorkerQueue,RunProcedure,DelegationLevel,TimeOut,ReqDescription,CallBackProcedure,
                     InputCase,Authorization,licenseName,priorityAdjustment,scheduledAt)
                }
                Body: {
                    ! Parameter validation
                    if RunProcedure = '' then
                            raise error "The RunProcedure argument cannot be empty" code 'PRO-Empty-RunProcedure-argument' ;
                            return 0;
                    elseif TimeOut < 0 then
                            raise error "Invalid timeout value" code 'PRO-Invalid-timeout-value' ;
                            return 0;
                    endif;
                    
                    ! Adjustments
                    if (CallBackProcedure = '') then
                            CallBackProcedure := 'pro::session::DefaultCallBack';
                    else
                            !Check if the given procedure has exactly one string as an input argument
                            if not management::CheckCallbackProcedurePrototype(CallBackProcedure) then
                                    raise error "Callback procedure " + CallBackProcedure + " does not have exactly one string parameter as input argument" code 'PRO-Invalid-callback-prototype' ;
                                    return 0 ;
                            endif ;
                    endif;
                    
                    ! Initialize PRO (if not initialized yet)
                    ret := Initialize();
                    if not HandleError(ret,"PROInitialize") then return 0; endif;
                    
                    if (not InputCase) then
                            ! Save the case to be processed in the Storage Service
                            ret := version::SaveInputCase(GetPROTempFolder + "\\" + version::ManagedSessionInputCaseName);
                    
                            if (ret = 2) then
                                    ! no content stored in case, just register empty input case
                                    InputCase := "-";
                            elseif (ret = 1) then
                                    ret := storage::GetBucketInfo(GetPROSUserBucket,"ManagedSessions_"+ModelName+"_"+ModelVersion,tmpNum,tmpAuth,tmpDate);
                                    if not HandleError(ret,"GetBucketInfo") then return 0; endif;
                                    if (tmpNum = -1) then
                                                    ret := storage::CreateBucket(GetPROSUserBucket,"ManagedSessions_"+ModelName+"_"+ModelVersion,Authorization);
                                                    if not HandleError(ret,"CreateBucket") then return 0; endif;
                                    endif;
                                    ret := storage::PutObjectVersion(BucketBasePath,version::ManagedSessionInputCaseName,GetPROTempFolder + "\\" + version::ManagedSessionInputCaseName,Authorization,tmpVersion);
                    
                                    if not HandleError(ret,"PutObjectVersion") then return 0; endif;
                            endif;
                    endif;
                    
                    ! Request a new session (do not start it yet; prepare the job first)
                    ret := sessionmanager::NewSession(ModelName, ModelVersion, MaxInitTimeout, MaxCloseTimeout, Authorization, tmpSessionID, ClientQueue, WorkerQueue);
                    if not HandleError(ret,"NewSession") then return 0; endif;
                    
                    ! Start to listen to the worker agent of that session
                    ret := GetListeningConnection(tmpConnection);
                    if not HandleError(ret,"GetListeningConnection") then
                            ! Close the session manually
                            ret := sessionmanager::EndSession(tmpSessionID);
                            HandleError(ret,"EndSession");
                            return 0;
                    endif;
                    ret := messaging::AddQueueToConnection(ClientQueue, tmpConnection);
                    if not HandleError(ret,"AddQueueToConnection") then
                            ! Close the session manually
                            ret := sessionmanager::EndSession(tmpSessionID);
                            HandleError(ret,"EndSession");
                            return 0;
                    endif;
                    
                    ! Register the session and its properties in PROG
                    SetElementAdd(ManagedSessionsActive,ManagedSession,tmpSessionID);
                    ClientQueueID(ManagedSession) := ClientQueue;
                    WorkerQueueID(ManagedSession) := WorkerQueue;
                    RunTimeOut(ManagedSession) := TimeOut;
                    RequestTime(ManagedSession) := CurrentToString("%c%y-%m-%d %H:%M:%S");
                    
                    if (InputCase) then
                            ! only pass over non-empty input cases.
                            if (InputCase <> "-") then
                                ! Wrap InputCase id to make distinguishable from input case created here.
                                VersionID(ManagedSession) := "[" + InputCase + "]";
                            endif;
                    else
                            VersionID(ManagedSession) := tmpVersion;
                    endif;
                    
                    version::CaseFilePath(CurrentCase,tmpVersion);
                    if(tmpVersion <> "") then
                            OriginalCasePath(ManagedSession) := tmpVersion;
                    else
                            tmpVersion := "unnamed-case";
                    endif;
                    
                    if(ReqDescription="")then
                            tmpVersion := FindReplaceStrings(tmpVersion, "\\", "/");
                            tmpNum := FindNthString(tmpVersion, "/", -1);
                            if (tmpNum <> 0) then
                                    tmpVersion := SubString(tmpVersion, tmpNum+1, StringLength(tmpVersion));
                            endif;
                            tmpNum := FindNthString(tmpVersion, ".", -1);
                            if (tmpNum <> 0) then
                                    tmpVersion := SubString(tmpVersion, 1, tmpNum-1);
                            endif;
                    
                            ReqDescription := tmpVersion + CurrentToString("@%c%y-%m-%d %H:%M:%S");
                    endif;
                    
                    RequestDescription(ManagedSession) := ReqDescription;
                    RequestProcedure(ManagedSession) := RunProcedure;
                    ActiveStatus(ManagedSession) := 1; ! Set to active status
                    ErrorCode(ManagedSession) := 0;  ! success
                    
                    sessionmanager::SetRequestInfo(ManagedSession, OriginalCasePath(ManagedSession), RequestDescription(ManagedSession),
                                        RequestProcedure(ManagedSession), RunTimeOut(ManagedSession), VersionID(ManagedSession),
                                        ResponseVersionID(ManagedSession),MessageLogVersionID(ManagedSession),
                                        ErrorMessage(ManagedSession), ActiveStatus(ManagedSession), ErrorCode(ManagedSession));
                    
                    !  Request task to the session
                    ret := OptimizeCurrentCaseProxy(RunProcedure,DelegationLevel,CallBackProcedure,VersionID(ManagedSession),Authorization);
                    if not (ret) then
                            ! Close the session manually
                            ret := sessionmanager::EndSession(tmpSessionID);
                            HandleError(ret,"EndSession");
                            return 0;
                    endif;
                    
                    if (not DebugServerSession) then
                            ! Request the session manager to start the auto close session (job prepared)
                            ret := sessionmanager::StartSession(tmpSessionID,licenseName,priorityAdjustment,scheduledAt);
                            if not HandleError(ret,"StartSession") then
                                ! Problems with the session: close manually
                                ret := sessionmanager::EndSession(tmpSessionID);
                                HandleError(ret,"EndSession");
                                SetElementAdd(sessionsToRemove, sessionToRemove, tmpSessionID);
                                ret := sessionmanager::ClearSessionDatabase(sessionsToRemove, warnString);
                                HandleError(ret,"ClearSessionDatabase");
                                return 0;
                            endif;
                    else
                            ! Add additional arguments to ReadArguments to allow starting a debug session
                            ReadArguments('_pro-session-id') := tmpSessionID;
                    
                            ! write a file that can be used to initialize a debug AIMMS session to host the optimization worker
                            write ReadArguments to file "debug_arguments.txt" ;
                    endif;
                    
                    LastStartedSession := ManagedSession;
                    
                    return 1;
                }
                ElementParameter RunProcedure {
                    Range: AllProcedures;
                    Default: '';
                    Property: Input;
                    Comment: "Procedure to be run remotely";
                }
                Parameter DelegationLevel {
                    Property: Input;
                }
                Parameter TimeOut {
                    Default: 3600000;
                    Property: Optional;
                    Comment: "Maximal running time before aborting the procedure (in miliseconds)";
                }
                ElementParameter CallBackProcedure {
                    Range: AllProcedures;
                    Default: '';
                    Property: Optional;
                    Comment: "Procedure to be called back when the procedure had run.";
                }
                Parameter ret;
                StringParameter tmpCont {
                    InitialData: "";
                }
                Parameter tmpNum {
                    InitialData: 0;
                }
                StringParameter tmpAuth {
                    InitialData: "";
                }
                StringParameter tmpDate {
                    InitialData: "";
                }
                StringParameter tmpVersion {
                    InitialData: "";
                }
                StringParameter tmpBucket {
                    InitialData: "";
                }
                StringParameter tmpSessionID {
                    InitialData: "";
                }
                StringParameter tmpConnection {
                    InitialData: "";
                }
                StringParameter ReqDescription {
                    Property: Optional;
                }
                StringParameter Authorization {
                    Property: Optional;
                }
                StringParameter WorkerQueue {
                    Property: Output;
                    InitialData: "";
                }
                StringParameter ClientQueue {
                    Property: Output;
                    InitialData: "";
                }
                StringParameter InputCase {
                    Property: Optional;
                }
                StringParameter licenseName {
                    Property: Optional;
                }
                Parameter priorityAdjustment {
                    Range: integer;
                    Property: Optional;
                }
                StringParameter scheduledAt {
                    Property: Optional;
                }
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
            }
            Procedure OptimizeCurrentCase {
                Arguments: (RunProcedure,DelegationLevel,CallBackProcedure,CaseVersion,Authorization);
                Body: {
                    ! if we're debugging a server-side session, we jump into the AIMMS debugger here
                    ! such that the entire execution taking place in a server session can be debugged.
                    if (DebugServerSession) then
                            DebuggerBreakpoint();
                    endif;
                    
                    ! do not allow incoming priority messages prior to running the user code
                    messaging::BlockIncomingMessages();
                    
                    ! set worker state
                    workerErrorCode := 0;
                    workerDelegationLevel := DelegationLevel;
                    
                    if ( not CaseVersion ) then
                        ! no input case, which is perfectly fine
                        ret := 1;
                    elseif ( SubString(CaseVersion,1,1) = "[" ) then
                            ! Strip wrapping "[" and "]" to indicate shared case file
                            SharedInputCase := 1;
                            CaseVersion := SubString(CaseVersion,2,StringLength(CaseVersion)-1);
                    
                            if (StringLength(CaseVersion) > 4 and SubString(CaseVersion,1,4) = "PRO:") then
                                ! assume case file which is stored in PRO central storage
                                ret := version::LoadCaseByFile(CaseVersion);
                            else
                                ! Get the case file in the Storage Service
                                ret := GetObjectVersion(CaseVersion,PROTempFolder,tmpFileToLoad);
                                version::LoadCaseByFile(PROTempFolder + "\\" + tmpFileToLoad);
                            endif;
                    else
                            ! Get the case file in the Storage Service
                            ret := GetObjectVersion(CaseVersion,PROTempFolder,tmpFileToLoad);
                            version::LoadCaseByFile(PROTempFolder + "\\" + tmpFileToLoad);
                    endif;
                    
                    if not (ret) then
                            ret := management::GetLastError(ret,tmpErrorDescription);
                            if (ret) then CurrentErrorMessage += " [pro] " + tmpErrorDescription;
                            else CurrentErrorMessage += " [pro] Unknown error: GetObjectVersion"; endif;
                            workerErrorCode := ret;
                    endif;
                    
                    ! Load data and run (do not halt on errors)
                    block
                            Apply(PostLoadInputCaseHook);
                    
                            ! stop blocking priority messages until just before the main user routine.
                            messaging::UnblockIncomingMessages();
                            ! wait for the message describing the actual workload
                            ret := messaging::WaitForMessagesInternal(pro::workerQueueID,PROMFLAG_REQUEST + PROMFLAG_SYNC_ONLY,30000);
                            ! wait for any other messages with additional workload
                            repeat
                                    ret := messaging::WaitForMessagesInternal(pro::workerQueueID,PROMFLAG_REQUEST,0);
                                    break when ret=0;
                            endrepeat;
                    onerror err do
                            if (errh::Severity(err) <> 'warning') then
                                tmpErrorDescription := FormatString("[pro] %e %e: %s", errh::Category(err), errh::Severity(err), errh::Message(err));
                    
                                if nrOfErrors = 0 then
                                        CurrentErrorMessage := tmpErrorDescription;
                                        workerErrorCode := 3000;
                                endif;
                    
                                nrOfErrors += 1;
                            endif;
                    
                            management::LocalLogError(tmpErrorDescription);
                            errh::MarkAsHandled(err);
                    endblock;
                    
                    ! check whether there are still error messages that occurred during calls
                    ! to WaitForMessages. If so, they have to be taken into account in the error count
                    
                    if (messaging::GetRuntimeErrors()) then
                            tmpErrorDescription := FormatString("[pro] runtime error: %s", messaging::GetRuntimeErrors());
                    
                            if nrOfErrors = 0 then
                                    CurrentErrorMessage := tmpErrorDescription;
                                    workerErrorCode := 3000;
                            endif;
                    
                            nrOfErrors += 1;
                            management::LocalLogError(tmpErrorDescription);
                    endif;
                    
                    ! do not allow incoming priority messages after running the user code
                    messaging::BlockIncomingMessages();
                    
                    InitializeUserProjectBuckets(Authorization);
                    
                    if (SaveSessionMessages) then
                        if (FileExists("log\\messages.log")) then
                            LogFileLocation := "log\\messages.log";
                        elseif (FileExists(PROTempFolder + "\\messages.log")) then
                            LogFileLocation := PROTempFolder + "\\messages.log";
                        endif;
                        ! Store the messages.log file in the server if present
                        if (LogFileLocation) then
                                ret := storage::PutObjectVersion(BucketBasePath, "messages.log", LogFileLocation, Authorization, tmpLogFile);
                                if not (ret) then
                                        ret := management::GetLastError(ret,tmpErrorDescription);
                                        if (ret) then CurrentErrorMessage += "[pro] " + tmpErrorDescription;
                                        else CurrentErrorMessage += "[pro] Unknown error: PutObjectVersion"; endif;
                                        workerErrorCode := ret;
                                endif;
                        endif;
                    endif;
                    
                    ! Update the case file in the Storage Service, but only if there are no runtime errors
                    if (not nrOfErrors) then
                        ret := version::SaveOutputCase(PROTempFolder + "\\" + version::ManagedSessionOutputCaseName);
                    
                        if (ret = 1) then
                                ! Saved output exists, ret = 2 implies no case file stored because of empty identifier set
                                ret := storage::PutObjectVersion(BucketBasePath, version::ManagedSessionOutputCaseName, PROTempFolder + "\\" + version::ManagedSessionOutputCaseName, Authorization, tmpResponseCase);
                                if not (ret) then
                                        ret := management::GetLastError(ret,tmpErrorDescription);
                                        if (ret) then CurrentErrorMessage += "[pro] " + tmpErrorDescription;
                                        else CurrentErrorMessage += "[pro] Unknown error: UpdateObjectVersion"; endif;
                                        workerErrorCode := ret;
                                endif;
                        endif;
                    endif;
                    
                    ! Update the request info at the server to communicate the output data to the client
                    workerOutputDataVersion := tmpResponseCase;
                    workerLogFileVersion := tmpLogFile;
                    workerErrorMessage := CurrentErrorMessage;
                    
                    PROWorkerSaveRequestInfo;
                    
                    messaging::UnblockIncomingMessages();
                    
                    ! Call client back
                    return OptimizationCallBackProxy(CallBackProcedure,workerSessionID);
                }
                Comment: "OBS: This procedure is supposed to be executed in the server side.";
                ElementParameter RunProcedure {
                    Range: AllProcedures;
                    Default: 'pro::session::AuxEmpty';
                    Property: Input;
                }
                Parameter DelegationLevel {
                    Property: Input;
                }
                ElementParameter CallBackProcedure {
                    Range: AllProcedures;
                    Property: Input;
                }
                StringParameter CaseVersion {
                    Property: Input;
                }
                StringParameter Authorization {
                    Default: "";
                    Property: Input;
                }
                Parameter SharedInputCase;
                Parameter ret;
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
                Parameter nrOfErrors {
                    Default: 0;
                }
                StringParameter tmpErrorDescription {
                    InitialData: "";
                }
                StringParameter tmpFileToLoad {
                    InitialData: "";
                }
                StringParameter tmpResponseCase {
                    InitialData: "";
                }
                StringParameter tmpLogFile {
                    InitialData: "";
                }
                StringParameter LogFileLocation;
            }
            Procedure OptimizeCurrentCaseProxy {
                Arguments: (RunProcedure,DelegationLevel,CallBackProcedure,CaseVersion,Authorization);
                Body: {
                    ! First, send message to run OptimizeCurrentCase remotely
                    ret := client::SendRunProcedure(
                            WorkerQueueID(ManagedSession),
                            'pro::session::OptimizeCurrentCase',
                            'pro::session::OptimizeCurrentCaseProxy',
                            RunTimeOut(ManagedSession),
                            PROMFLAG_SESSION + PROMFLAG_REQUEST
                    );
                    HandleError(ret);
                    
                    ! Next, send messages to remotely execute RunProcedure synchronously
                    ! from within OptimizeCurrentCase. Timeout is ignored for SYNC_ONLY messages
                    ret := client::SendRunProcedure(
                            WorkerQueueID(ManagedSession),
                            RunProcedure,
                            RunProcedure,
                            -1,
                            PROMFLAG_SESSION + PROMFLAG_REQUEST + PROMFLAG_SYNC_ONLY
                    );
                    HandleError(ret);
                    
                    return ret;
                }
                Comment: "OBS: This procedure is supposed to be executed in the server side.";
                ElementParameter RunProcedure {
                    Range: AllProcedures;
                    Default: 'pro::session::AuxEmpty';
                    Property: Input;
                }
                Parameter DelegationLevel {
                    Property: Input;
                }
                ElementParameter CallBackProcedure {
                    Range: AllProcedures;
                    Property: Input;
                }
                StringParameter CaseVersion {
                    Property: Input;
                }
                StringParameter Authorization {
                    Default: "";
                    Property: Input;
                }
                Parameter ret;
            }
            Procedure OptimizeCurrentCaseInterrupted {
                Arguments: (CaseVersion,Authorization);
                Body: {
                    InitializeUserProjectBuckets(Authorization);
                    
                    ! Put the messages.log file in the server
                    if (SaveSessionMessages) then
                        if (FileExists("log\\messages.log")) then
                            LogFileLocation := "log\\messages.log";
                        elseif (FileExists(PROTempFolder + "\\messages.log")) then
                            LogFileLocation := PROTempFolder + "\\messages.log";
                        endif;
                        ! Store the messages.log file in the server if present
                        if (LogFileLocation) then
                                ret := storage::PutObjectVersion(BucketBasePath, "messages.log", LogFileLocation, Authorization, tmpLogFile);
                                if not (ret) then
                                        ret := management::GetLastError(ret,tmpErrorDescription);
                                        if (ret) then CurrentErrorMessage += "[pro] " + tmpErrorDescription;
                                        else CurrentErrorMessage += "[pro] Unknown error: PutObjectVersion"; endif;
                                        workerErrorCode := ret;
                                endif;
                        endif;
                    endif;
                    
                    ! If no error message is presented, update CurrentErrorMessage
                    if (CurrentErrorMessage = "") then
                            CurrentErrorMessage := "Procedure terminated by user request";
                    endif;
                    
                    ! Register the finished session and its properties in PROG
                    workerErrorMessage := CurrentErrorMessage;
                    workerLogFileVersion := tmpLogFile;
                    
                    PROWorkerSaveRequestInfo;
                    
                    ! Call client back
                    return OptimizationCallBackProxy('pro::session::EmptyCallBack',workerSessionID);
                }
                Comment: {
                    "OBS: This procedure is supposed to be executed in the server side, when the user sends a
                    request to interrupt the current execution. As it has a \"halt\" effect in PRO execution,
                    this procedure set proper information about the session in the environment."
                }
                StringParameter CaseVersion {
                    Property: Input;
                }
                Parameter ret;
                Set Containers {
                    Index: CONT, CONT2;
                    Parameter: Container, Container2;
                }
                Set Items {
                    Index: ITEM, ITEM2;
                    Parameter: ContItem;
                }
                StringParameter Value {
                    IndexDomain: (CONT,ITEM);
                }
                ElementParameter Ref {
                    IndexDomain: (CONT,ITEM);
                    Range: Containers;
                }
                StringParameter Authorization {
                    Property: Input;
                }
                Parameter tmpNum {
                    InitialData: 0;
                }
                StringParameter tmpAuth {
                    InitialData: "";
                }
                StringParameter tmpDate {
                    InitialData: "";
                }
                StringParameter tmpErrorDescription;
                StringParameter tmpLogFile;
                StringParameter LogFileLocation;
            }
            Procedure OptimizationCallBack {
                Arguments: (CallBackProcedure,SessionID);
                Body: {
                    ! Identify the session and register event
                    SessionElement := StringToElement(ManagedSessions,SessionID);
                    if (SessionElement <> '') then
                            ! Collect session properties
                    
                            sessionmanager::GetRequestInfo(SessionElement, OriginalCasePath(SessionElement), RequestDescription(SessionElement),
                                        RequestProcedure(SessionElement), RunTimeOut(SessionElement), VersionID(SessionElement),
                                        ResponseVersionID(SessionElement),MessageLogVersionID(SessionElement),
                                        ErrorMessage(SessionElement), ActiveStatus(SessionElement), ErrorCode(SessionElement));
                    
                            ! Update status
                            LastKnownStatus(SessionElement) := PROTS_FINISHED;
                    
                            ! Finish progress window, if activated
                            if(ActiveSession = SessionID) then
                                    ActiveSession := '';
                            endif;
                    
                            ! Remove the session from the set of active sessions on which we actively listen on the queue
                            GetListeningConnection(tmpConnection);
                            messaging::RemoveQueueFromConnection(ClientQueueID(SessionElement), tmpConnection);
                    
                            ManagedSessionsActive -= SessionElement;
                            ! Unset active status in server, so that it won't be reloaded next time
                            ActiveStatus(SessionElement) := 0;
                    
                            sessionmanager::SetRequestInfo(SessionElement, OriginalCasePath(SessionElement), RequestDescription(SessionElement),
                                    RequestProcedure(SessionElement), RunTimeOut(SessionElement), VersionID(SessionElement),
                                    ResponseVersionID(SessionElement), MessageLogVersionID(SessionElement),
                                    ErrorMessage(SessionElement), ActiveStatus(SessionElement), ErrorCode(SessionElement));
                    
                            ! Call-back procedure
                            BLOCK;
                                    if (CallBackProcedure <> '') then
                                            Apply(CallBackProcedure,SessionID);
                                    endif;
                    
                            ONERROR err DO
                                    tmpErrorDescription := FormatString("[pro] %e %e: %s", errh::Category(err), errh::Severity(err), errh::Message(err));
                    
                                    management::LocalLogError(tmpErrorDescription);
                                    CurrentErrorMessage += tmpErrorDescription;
                            ENDBLOCK;
                    
                    else
                            ! Silently ignore the callback, it may be for a session that has been just removed by the user.
                            ! raise error "Received response for unknown session " + SessionID code 'PRO-Response-for-unknown-session' ;
                    endif;
                }
                ElementParameter CallBackProcedure {
                    Range: AllProcedures;
                    Default: 'pro::session::DefaultCallBack';
                    Property: Input;
                }
                StringParameter SessionID {
                    Property: Input;
                }
                ElementParameter SessionElement {
                    Range: ManagedSessions;
                }
                Parameter ret;
                ElementParameter err {
                    Range: errh::PendingErrors;
                }
                StringParameter tmpErrorDescription {
                    InitialData: "";
                }
                Set Containers {
                    Index: CONT, CONT2;
                    Parameter: Container, Container2;
                }
                Set Items {
                    Index: Item, ITEM2;
                    Parameter: PeItem;
                }
                StringParameter Value {
                    IndexDomain: (CONT,ITEM);
                }
                ElementParameter Ref {
                    IndexDomain: (CONT,ITEM);
                    Range: Containers;
                }
                StringParameter tmpContActive {
                    InitialData: "";
                }
                StringParameter tmpConnection;
            }
            Procedure OptimizationCallBackProxy {
                Arguments: (CallBackProcedure,SessionID);
                Body: {
                    ret := client::SendRunProcedure(
                            pro::clientQueueID,
                            'pro::session::OptimizationCallBack',
                            'pro::session::OptimizationCallBackProxy',
                            -1,
                            PROMFLAG_SESSION + PROMFLAG_RESPONSE
                    );
                    HandleError(ret);
                    
                    ! Notify that a callback is called by the worker
                    pro::workerCallbackCalled := 1;
                    
                    return ret;
                }
                ElementParameter CallBackProcedure {
                    Range: AllProcedures;
                    Default: 'pro::session::DefaultCallBack';
                    Property: Input;
                }
                StringParameter SessionID {
                    Property: Input;
                }
                Parameter ret;
            }
            Procedure InitializeUserProjectBuckets {
                Arguments: (Authorization);
                Body: {
                    ! Check for the existence of the model-specific user directory, and if not present, create it.
                    ret := storage::GetBucketInfo(GetPROSUserBucket,"ManagedSessions_"+ModelName+"_"+ModelVersion,tmpNum,tmpAuth,tmpDate);
                    if not (ret) then
                            ret := management::GetLastError(ret,tmpErrorDescription);
                            if (ret) then CurrentErrorMessage += " [pro] " + tmpErrorDescription;
                            else CurrentErrorMessage += " [pro] Unknown error: GetBucketInfo"; endif;
                            workerErrorCode := ret;
                    endif;
                    if (tmpNum = -1) then
                            ret := storage::CreateBucket(GetPROSUserBucket,"ManagedSessions_"+ModelName+"_"+ModelVersion,Authorization);
                            if not (ret) then
                                    ret := management::GetLastError(ret,tmpErrorDescription);
                                    if (ret) then CurrentErrorMessage += " [pro] " + tmpErrorDescription;
                                    else CurrentErrorMessage += " [pro] Unknown error: CreateBucket"; endif;
                                    workerErrorCode := ret;
                            endif;
                    endif;
                    
                    return ret;
                }
                Parameter ret;
                Parameter tmpNum {
                    InitialData: 0;
                }
                StringParameter tmpAuth {
                    InitialData: "";
                }
                StringParameter tmpDate {
                    InitialData: "";
                }
                StringParameter tmpErrorDescription {
                    InitialData: "";
                }
                StringParameter Authorization {
                    Property: Input;
                }
            }
            Procedure InitializeManagedSessions {
                Body: {
                    ! Load session information from the server
                    ret := LoadManagedSessions;
                    if not ret then return 0; endif;
                    
                    return 1;
                }
                Parameter ret {
                    InitialData: -1;
                }
            }
            Procedure AuxEmpty {
                Body: {
                    ! Does nothing
                }
                Comment: "Only to have a fixed dummy procedure to use as default";
            }
        }
        Module WebUI_Support {
            Prefix: webui;
            Section Internal_Declarations {
                Section Case_Management {
                    Function GetWebUICaseStoragePath {
                        Range: string;
                        Body: {
                            GetWebUICaseStoragePath := FormatString("PRO:/UserData/%s/%s/Cases/%s",PROEnvironment,PROUserName,ModelName);
                        }
                    }
                    Procedure LoadWebUICase {
                        Arguments: (casename);
                        Body: {
                            WebUICaseStoragePath := GetWebUICaseStoragePath;
                            StoragePath := FormatString("%s/%s",WebUICaseStoragePath,casename);
                            
                            management::LocalLogInfo("LoadWebUICase from PRO server : " + StoragePath);
                            
                            if (not CaseFileMerge(StoragePath)) then
                            	pro::management::PassMessage(2,CurrentErrorMessage);
                            endif;
                        }
                        StringParameter casename {
                            Property: Input;
                        }
                        StringParameter WebUICaseStoragePath;
                        StringParameter StoragePath;
                    }
                    Procedure SaveWebUICase {
                        Arguments: (casename);
                        Body: {
                            WebUICaseStoragePath := GetWebUICaseStoragePath;
                            StoragePath := FormatString("%s/%s",WebUICaseStoragePath,casename);
                            
                            management::LocalLogInfo("SaveWebUICase to PRO server : " + StoragePath);
                            
                            WebUICaseIdentifiers := AllIdentifiers;
                            if ( StringToElement(WebUICaseIdentifiers,"webui::CurrentCaseIsDirty") <> '' ) then
                            	WebUICaseIdentifiers -= 'webui::CurrentCaseIsDirty';
                            endif;
                            if ( StringToElement(WebUICaseIdentifiers,"webui::CurrentCasePath") <> '' ) then
                            	WebUICaseIdentifiers -= 'webui::CurrentCasePath';
                            endif;
                            
                            if (not CaseFileSave(StoragePath,WebUICaseIdentifiers)) then
                            	pro::management::PassMessage(2,CurrentErrorMessage);
                            	return 0;
                            endif;
                            
                            return 1;
                        }
                        StringParameter casename {
                            Property: Input;
                        }
                        StringParameter WebUICaseStoragePath;
                        StringParameter StoragePath;
                        Set WebUICaseIdentifiers {
                            SubsetOf: AllIdentifiers;
                        }
                    }
                    Procedure ExistsWebUICase {
                        Arguments: (casename);
                        Body: {
                            StoragePath := GetWebUICaseStoragePath + "/";
                            ! strip "PRO:" from path
                            len := StringLength(StoragePath);
                            StoragePath := SubString(StoragePath,5,len-1);
                            
                            management::LocalLogInfo("ExistsWebUICase on PRO server : " + StoragePath);
                            
                            storage::GetObjectInfo(StoragePath,casename,objFileName,objFileType,numberOfVersions,authorization,lastVersionID);
                            
                            management::LocalLogInfo("ExistsWebUICase sees " + numberOfVersions + " versions");
                            
                            return numberOfVersions;
                        }
                        StringParameter casename {
                            Property: Input;
                        }
                        StringParameter StoragePath;
                        Parameter len;
                        Parameter numberOfVersions;
                        StringParameter objFileName;
                        StringParameter objFileType;
                        StringParameter authorization;
                        StringParameter lastVersionID;
                    }
                    Procedure CreateWebUICase {
                        Arguments: (casename);
                        Body: {
                            numberOfversions := ExistsWebUICase(casename);
                            if ( numberOfversions > 0 ) then
                            	return /*Conflict*/ 409;
                            else
                            	return SaveWebUICase(casename);
                            endif;
                        }
                        StringParameter casename {
                            Property: Input;
                        }
                        StringParameter WebUICaseStoragePath;
                        StringParameter StoragePath;
                        Parameter numberOfversions;
                    }
                    Procedure DeleteWebUICase {
                        Arguments: (casename);
                        Body: {
                            StoragePath := GetWebUICaseStoragePath + "/";
                            ! strip "PRO:" from path
                            len := StringLength(StoragePath);
                            StoragePath := SubString(StoragePath,5,len-1);
                            
                            management::LocalLogInfo("DeleteWebUICase on PRO server : " + StoragePath);
                            
                            storage::DeleteObjectAllVersions(StoragePath,casename);
                        }
                        StringParameter casename {
                            Property: Input;
                        }
                        StringParameter WebUICaseStoragePath;
                        Parameter len;
                        StringParameter StoragePath;
                    }
                    Section State_Management {
                        Function GetWebUIStateStoragePath {
                            Arguments: (DataSessionID);
                            Range: string;
                            Body: {
                                WebUICaseStoragePath := GetWebUICaseStoragePath;
                                GetWebUIStateStoragePath := FormatString("%s/WebUIStates/%s.data",WebUICaseStoragePath,DataSessionID);
                            }
                            StringParameter DataSessionID {
                                Property: Input;
                            }
                            StringParameter WebUICaseStoragePath;
                        }
                        Procedure ExistsWebUIState {
                            Body: {
                                WebUICaseStoragePath := GetWebUICaseStoragePath;
                                StoragePath := FormatString("%s/WebUIStates/",WebUICaseStoragePath);
                                
                                ! strip "PRO:" from path
                                len := StringLength(StoragePath);
                                StoragePath := SubString(StoragePath,5,len-1);
                                
                                DataSessionID := ReadArguments('_pro-webui-session-id');
                                StateName := FormatString("%s.data",DataSessionID);
                                
                                management::LocalLogInfo("ExistsWebUIState on PRO server : " + StoragePath);
                                
                                storage::GetObjectInfo(StoragePath,StateName,objFileName,objFileType,numberOfVersions,authorization,lastVersionID);
                                
                                management::LocalLogInfo("ExistsWebUIState sees " + numberOfVersions + " versions");
                                
                                return numberOfVersions;
                            }
                            StringParameter DataSessionID;
                            StringParameter WebUICaseStoragePath;
                            StringParameter StoragePath;
                            StringParameter StateName;
                            Parameter len;
                            Parameter numberOfVersions;
                            StringParameter objFileName;
                            StringParameter objFileType;
                            StringParameter authorization;
                            StringParameter lastVersionID;
                        }
                        Procedure RestoreWebUIState {
                            Body: {
                                DataSessionID := ReadArguments('_pro-webui-session-id');
                                
                                Apply(PreRestoreWebUIStateHook,DataSessionID);
                                
                                numberOfVersions := ExistsWebUIState;
                                if ( numberOfVersions > 0 ) then
                                	StoragePath := GetWebUIStateStoragePath(DataSessionID);
                                	Message := "Restoring WebUI state from '" + StoragePath + "'";
                                	display Message;
                                	pro::management::PassMessage(3,Message);
                                
                                	if (not CaseFileMerge(StoragePath)) then
                                		pro::management::PassMessage(2,CurrentErrorMessage);
                                	endif;
                                endif;
                                
                                Apply(PostRestoreWebUIStateHook,DataSessionID);
                            }
                            StringParameter DataSessionID;
                            StringParameter Message;
                            StringParameter StoragePath;
                            Parameter numberOfVersions;
                        }
                        Procedure SaveWebUIState {
                            Body: {
                                DataSessionID := ReadArguments('_pro-webui-session-id');
                                
                                Apply(PreSaveWebUIStateHook,DataSessionID);
                                
                                StoragePath := GetWebUIStateStoragePath(DataSessionID);
                                Message := "Saving WebUI state to '" + StoragePath + "'";
                                display Message;
                                pro::management::PassMessage(3,Message);
                                
                                if (not CaseFileSave(StoragePath,AllIdentifiers)) then
                                	pro::management::PassMessage(2,CurrentErrorMessage);
                                endif;
                                
                                Apply(PostSaveWebUIStateHook,DataSessionID);
                            }
                            StringParameter DataSessionID;
                            StringParameter Message;
                            StringParameter StoragePath;
                        }
                    }
                }
                Procedure QuitWebUI {
                    Body: {
                        DataSessionID := ReadArguments('_pro-webui-session-id');
                        
                        Apply(PreQuitWebUIHook,DataSessionID);
                        
                        Message := "Quiting WebUI for session with id " + DataSessionID;
                        display Message;
                        pro::management::PassMessage(3,Message);
                    }
                    StringParameter DataSessionID;
                    StringParameter Message;
                }
            }
            Section Public_Declarations {
                ElementParameter PreSaveWebUIStateHook {
                    Range: AllProcedures;
                    Default: 'pro::webui::EmptyCallback';
                    Property: NoSave;
                }
                ElementParameter PostSaveWebUIStateHook {
                    Range: AllProcedures;
                    Default: 'pro::session::EmptyCallBack';
                    Property: NoSave;
                }
                ElementParameter PreRestoreWebUIStateHook {
                    Range: AllProcedures;
                    Default: 'pro::session::EmptyCallBack';
                    Property: NoSave;
                }
                ElementParameter PostRestoreWebUIStateHook {
                    Range: AllProcedures;
                    Default: 'pro::session::EmptyCallBack';
                    Property: NoSave;
                }
                ElementParameter PreQuitWebUIHook {
                    Range: AllProcedures;
                    Default: 'pro::session::EmptyCallBack';
                    Property: NoSave;
                }
                Procedure EmptyCallback {
                    Arguments: (DataSessionID);
                    Body: {
                        ! Does nothing
                    }
                    StringParameter DataSessionID {
                        Property: Input;
                    }
                }
            }
        }
        Procedure BasicDataInitialization {
            Body: {
                ! Some basic initialization
                PROEnvironment   := "ROOT";
                PROUserName      := "";
                PROPassword      := "";
                PROLastUserName  := "";
                PROEndPoint      := "";
                PROAppCurrentDir := "";
                PROCriticalError := 1;
                CheckForNoEmpty  := 1;
                
                workerErrorMsg   := "";
                workerSessionID  := "";
                workerQueueID    := "";
                clientQueueID    := "";
                
                ModelDLLPath     := "AimmsProLibrary\\" + AimmsStringConstants('Architecture')+ "\\AimmsPROClient.dll";
                PROConfigFile    := "PROConf.xml";
                PROLogConfigFile := "PROLog.cfg";
                PROTempFolder    := "PROTemp";
                
                ModelVersion     := "undefined";
                ModelName        := "undefined";
                
                session::ManagedSessionsActive := data {};
            }
        }
        Procedure LibraryInitialization {
            Body: {
                ! Check if it have already been run
                if PROLibraryInit then return 1; endif;
                
                ! Initialize basic data from LibraryInitialization to prevent data reset to initial data after MEF recompile
                BasicDataInitialization;
                
                DetermineDataManagementStyle;
                
                ! Set the name of the current folder
                DirectoryGetCurrent(PROAppCurrentDir);
                
                ! Initialize internationalization module
                LocalizationInitialize;
                
                ! Read basic configuration
                IF FileExists("<prj>:PROFramework\\PROModel.cfg") THEN
                        ! Model was already used before: DLL should be on place
                        READ FROM FILE "<prj>:PROFramework\\PROModel.cfg";
                ENDIF;
                
                ! Load client configuration (end-point, temp folder, etc) in both command-line arguments and XML file
                PROLoadClientConfiguration;
                
                ! Initialization for developers and end-users
                IF (not IsRunningAtServer()) THEN
                        ! Check if is loaded without critical errors
                        IF NOT ((ModelName="") OR (ModelVersion="") OR (PROEndPoint="") OR (NOT FileExists(ModelDLLPath))) THEN
                                PROCriticalError := 0;
                        ENDIF;
                
                        ! If there is a shared ticket, connect immediately
                        IF ReadArguments('_pro-ticket') <> "" THEN
                                ret := Initialize();
                                if not HandleError(ret) then return 0; endif;
                        ENDIF;
                
                ELSE
                        ! No further initialization
                        PROCriticalError := 0;
                ENDIF;
                
                PROLibraryInit := 1;
                
                IF ReadArguments('_pro-webui-session-id') <> "" THEN
                	pro::webui::RestoreWebUIState();
                ENDIF;
                
                ! In case we're going to debug a server session, start listening to the server-side queue here.
                ! When the actual request comes in, we will automatically jump into the AIMMS debugger.
                if (DebugServerSession) then
                        PROWorkerInitialization;
                endif;
                
                RETURN 1;
            }
            Comment: {
                "If opened in GUI mode, this procedure have restricted access to the model; so, it only checks for the DLL
                and ask this same DLL to make an asynchronous call back to AIMMS to do the actual PRO initialization.
                See procedure: LibraryInitializationGUI."
            }
            Parameter ret;
            StringParameter tmpStr;
        }
        Procedure LibraryTermination {
            Body: {
                ! Finalize PRO if necessary, handle any error occurring in here
                ! to prevent unnecessary errors during logoff.
                block
                        if (not ModelDLLPath and FileExists("pro_arguments.txt")) then
                                PROLoadClientConfiguration;
                        endif;
                        if (management::IsInitialized()) then
                                Finalize;
                        endif;
                onerror err do
                        errh::MarkAsHandled(err,1) ;
                endblock;
                
                return 1 ;
            }
            ElementParameter err {
                Range: errh::PendingErrors;
            }
            Parameter ret;
        }
    }
    Section AIMMS_Version_Dependent_Functionalities {
        SourceFile: "AimmsPRO-%AIMMSPROLIBRARYVERSION%.ams";
    }
}
